<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benny&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-02T10:37:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Beeeeeeenny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tornado concurrent实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_concurrent/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_concurrent/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2018-04-02T10:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-concurrent"><a href="#tornado-concurrent" class="headerlink" title="tornado concurrent"></a>tornado concurrent</h2><p>用于处理线程和Futures的工具。Futures是python3.2中concurrent.futures包引入的并发编程模式。在本模块中，定义了一个兼容的Future类，它被设计用于协同工作，还有一些用于与concurrent.futures包交互的实用函数。</p><a id="more"></a><p>Future的设计目标是作为协程(coroutine)和IOLoop的媒介，从而将协程和IOLoop关联起来。<br>Future是异步操作结果的占位符，用于等待结果返回。通常作为函数IOLoop.add_future()的参数或 gen.coroutine协程中yield的返回值。<br>等到结果返回时，外部可以通过调用set_result()设置真正的结果，将结果保存在Future内存中，然后调用所有回调函数，恢复协程的执行，最后通过result()获取结果。</p><p>Future类通过self._done的值来判断本次Future操作是否结束，默认为False，当调用set_result()设置结果、或者调用set_exc_info()设置异常时会调用_set_done()修改其值，即表示本次操作已经完成。</p><ul><li><p>tornado.concurrent.Future.set_result()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, result)</span>:</span></span><br><span class="line">    <span class="comment"># 将结果保存到self._result</span></span><br><span class="line">    self._result = result</span><br><span class="line">    <span class="comment"># 修改self._done，并调用所有回调函数</span></span><br><span class="line">    self._set_done()</span><br></pre></td></tr></table></figure></li><li><p>tornado.concurrent.Future._set_done()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_done</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 修改self._done值，表示本次操作已完成</span></span><br><span class="line">    self._done = <span class="keyword">True</span></span><br><span class="line">    <span class="comment"># 循环执行self._callbacks中的回调函数，通过add_done_callback()定义</span></span><br><span class="line">    <span class="keyword">for</span> cb <span class="keyword">in</span> self._callbacks:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cb(self)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            app_log.exception(<span class="string">'Exception in callback %r for %r'</span>,</span><br><span class="line">                              cb, self)</span><br><span class="line">    self._callbacks = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></li><li><p>tornado.concurrent.Future.add_done_callback()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">    <span class="comment"># 添加本次Future操作完成时的回调函数，如果Future还没结束，则将回调函数加入</span></span><br><span class="line">    <span class="comment"># self._callbacks，以便结束时调用，如果已经结束，则直接运行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> self._done:</span><br><span class="line">        fn(self)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._callbacks.append(fn)</span><br></pre></td></tr></table></figure></li><li><p>tornado.concurrent.Future.result()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">    <span class="comment"># 清理日志</span></span><br><span class="line">    self._clear_tb_log()</span><br><span class="line">    <span class="comment"># 判断self._result结果是否为None，通过set_result()设置</span></span><br><span class="line">    <span class="keyword">if</span> self._result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self._result</span><br><span class="line">    <span class="comment"># 判断是否有异常信息，通过set_exc_info()设置</span></span><br><span class="line">    <span class="keyword">if</span> self._exc_info <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            raise_exc_info(self._exc_info)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 检查是否结束</span></span><br><span class="line">    self._check_done()</span><br><span class="line">    <span class="keyword">return</span> self._result</span><br></pre></td></tr></table></figure></li><li><p><div id="chain_future"></div>tornado.concurrent.chain_future()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain_future</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="comment"># 将两个Future对象关联在一起，一个完成，另一个也完成</span></span><br><span class="line">    <span class="comment"># “a”的结果（成功或失败）将被复制到“b”，除非在“a”结束之前，“b”已经完成或被取消。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(future)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> future <span class="keyword">is</span> a</span><br><span class="line">        <span class="comment"># 如果b已经完成或者取消，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> b.done():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (isinstance(a, TracebackFuture) <span class="keyword">and</span></span><br><span class="line">                isinstance(b, TracebackFuture) <span class="keyword">and</span></span><br><span class="line">                a.exc_info() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            b.set_exc_info(a.exc_info())</span><br><span class="line">        <span class="keyword">elif</span> a.exception() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            b.set_exception(a.exception())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b.set_result(a.result())</span><br><span class="line">    <span class="comment"># 将copy()添加到a的回调列表中</span></span><br><span class="line">    a.add_done_callback(copy)</span><br></pre></td></tr></table></figure></li></ul><p>首先会调用a.add_done_callback(copy)，若a已经完成则直接运行copy函数，否则加入到回调列表中等到a完成时再运行。copy函数将两个Future对象联系到了一起，用作结果返回、超时处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-concurrent&quot;&gt;&lt;a href=&quot;#tornado-concurrent&quot; class=&quot;headerlink&quot; title=&quot;tornado concurrent&quot;&gt;&lt;/a&gt;tornado concurrent&lt;/h2&gt;&lt;p&gt;用于处理线程和Futures的工具。Futures是python3.2中concurrent.futures包引入的并发编程模式。在本模块中，定义了一个兼容的Future类，它被设计用于协同工作，还有一些用于与concurrent.futures包交互的实用函数。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="concurrent" scheme="http://yoursite.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>tornado定时器PeriodicCallback实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_ioloop_PeriodicCallback/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_ioloop_PeriodicCallback/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2018-04-03T03:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-PeriodicCallback"><a href="#tornado-PeriodicCallback" class="headerlink" title="tornado PeriodicCallback"></a>tornado PeriodicCallback</h2><p>tornado.ioloop.PeriodicCallback是tornado实现的定时器。</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(tornado.web.Application)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        handlers = [</span><br><span class="line">            (<span class="string">r"/"</span>, HomeHandler),</span><br><span class="line">        ]</span><br><span class="line">        settings = dict(</span><br><span class="line">            debug=<span class="keyword">True</span>,</span><br><span class="line">        )</span><br><span class="line">        super(Application, self).__init__(handlers, **settings)</span><br></pre></td></tr></table></figure><a id="more"></a><p>当创建tornado Application时，如果设置“debug=True”，tornado会在源程序修改后自动编译，而不需要我们手动重启。</p><ul><li><p>tornado.web.Application.<strong>init</strong>()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=None, transforms=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             **settings)</span>:</span></span><br><span class="line">    <span class="comment">#####省略#####</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当设置了debug=True时，tornado会默认设置autoreload=True</span></span><br><span class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">'debug'</span>):</span><br><span class="line">        self.settings.setdefault(<span class="string">'autoreload'</span>, <span class="keyword">True</span>)</span><br><span class="line">        self.settings.setdefault(<span class="string">'compiled_template_cache'</span>, <span class="keyword">False</span>)</span><br><span class="line">        self.settings.setdefault(<span class="string">'static_hash_cache'</span>, <span class="keyword">False</span>)</span><br><span class="line">        self.settings.setdefault(<span class="string">'serve_traceback'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#####省略#####</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否设置了autoreload，如果设置了就会调用autoreload.start()，</span></span><br><span class="line">    <span class="comment"># 启动自动重载功能</span></span><br><span class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">'autoreload'</span>):</span><br><span class="line">        <span class="keyword">from</span> tornado <span class="keyword">import</span> autoreload</span><br><span class="line">        autoreload.start()</span><br></pre></td></tr></table></figure></li><li><p>tornado.autoreload.start()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(io_loop=None, check_time=<span class="number">500</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 获取IOLoop实例</span></span><br><span class="line">    io_loop = io_loop <span class="keyword">or</span> ioloop.IOLoop.current()</span><br><span class="line">    <span class="comment"># 如果当前IOLoop实例是弱引用的则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> io_loop <span class="keyword">in</span> _io_loops:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    _io_loops[io_loop] = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> len(_io_loops) &gt; <span class="number">1</span>:</span><br><span class="line">        gen_log.warning(<span class="string">"tornado.autoreload started more than once in the same process"</span>)</span><br><span class="line">    modify_times = &#123;&#125;</span><br><span class="line">    <span class="comment"># 生成回调函数</span></span><br><span class="line">    callback = functools.partial(_reload_on_update, modify_times)</span><br><span class="line">    <span class="comment"># 初始化tornado.PeriodicCallback定时器</span></span><br><span class="line">    scheduler = ioloop.PeriodicCallback(callback, check_time, io_loop=io_loop)</span><br><span class="line">    <span class="comment"># 开始执行定时器</span></span><br><span class="line">    scheduler.start()</span><br></pre></td></tr></table></figure></li><li><p>tornado.ioloop.PeriodicCallback.start()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 设置定时器运行中</span></span><br><span class="line">    self._running = <span class="keyword">True</span></span><br><span class="line">    <span class="comment"># 初始化下次的超时事件的最后期限</span></span><br><span class="line">    self._next_timeout = self.io_loop.time()</span><br><span class="line">    <span class="comment"># 关键方法，对下次超时事件的封装</span></span><br><span class="line">    self._schedule_next()</span><br></pre></td></tr></table></figure></li><li><p>tornado.ioloop.PeriodicCallback._schedule_next()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_schedule_next</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._running:</span><br><span class="line">        <span class="comment"># 获取当前时间</span></span><br><span class="line">        current_time = self.io_loop.time()</span><br><span class="line">        <span class="comment"># 如果当前时间已经超过了超时事件的最后期限，则重新设置超时时间</span></span><br><span class="line">        <span class="keyword">if</span> self._next_timeout &lt;= current_time:</span><br><span class="line">            <span class="comment"># self.callback_time为autoreload.start()方法中初始化定时器时传入的</span></span><br><span class="line">            <span class="comment"># check_time，即500毫秒</span></span><br><span class="line">            callback_time_sec = self.callback_time / <span class="number">1000.0</span></span><br><span class="line">            self._next_timeout += (math.floor((current_time - self._next_timeout) /</span><br><span class="line">                                              callback_time_sec) + <span class="number">1</span>) * callback_time_sec</span><br><span class="line">        <span class="comment"># 关键所在，添加超时事件，将self._run作为超时后的回调函数</span></span><br><span class="line">        self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)</span><br></pre></td></tr></table></figure></li><li><p>tornado.ioloop.PeriodicCallback._run()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 判断定时器是否还在运行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._running:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 调用autoreload.start()方法中初始化时传入的超时回调函数</span></span><br><span class="line">        <span class="keyword">return</span> self.callback()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        self.io_loop.handle_callback_exception(self.callback)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 无论如何，都会再次调用self._schedule_next()再次添加超时事件到IOLoop中，</span></span><br><span class="line">        <span class="comment"># 这样就会一直循环，即定时器操作</span></span><br><span class="line">        self._schedule_next()</span><br></pre></td></tr></table></figure></li></ul><p>在PeriodicCallback._schedule_next()的最后一行执行的添加超时事件就会被IOLoop下次循环中。</p><ul><li><p><div id="add_timeout"></div>tornado.ioloop.IOLoop.add_timeout()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_timeout</span><span class="params">(self, deadline, callback, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 判断超时事件的最后期限deadline是否为实数，一般为实数</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(deadline, numbers.Real):</span><br><span class="line">        <span class="keyword">return</span> self.call_at(deadline, callback, *args, **kwargs)</span><br><span class="line">    <span class="comment"># 在使用call_later()方法设置超时事件时deadline为datetime.timedelta类型</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(deadline, datetime.timedelta):</span><br><span class="line">        <span class="keyword">return</span> self.call_at(self.time() + timedelta_to_seconds(deadline),</span><br><span class="line">                            callback, *args, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Unsupported deadline %r"</span> % deadline)</span><br></pre></td></tr></table></figure></li></ul><p>tornado规定继承至IOLoop的子类必须实现add_timeout()或者call_at()方法，因为默认实现只是相互调用，而没有实质作用。tornado.ioloop.PollIOLoop则实现了call_at()。</p><ul><li><p>tornado.ioloop.PollIOLoop.call_at()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_at</span><span class="params">(self, deadline, callback, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化_Timeout对象，该对象是对超时事件的封装，同时重写了__lt__()、__le__()</span></span><br><span class="line">    <span class="comment"># 两个方法，实现了_Timeout的大小比较。</span></span><br><span class="line">    timeout = _Timeout(</span><br><span class="line">        deadline,</span><br><span class="line">        functools.partial(stack_context.wrap(callback), *args, **kwargs),</span><br><span class="line">        self)</span><br><span class="line">    <span class="comment"># 通过堆排序添加timeout到self._timeouts列表中，因此确定了self._timeouts[0]</span></span><br><span class="line">    <span class="comment"># 总是最小的，即最后期限deadline最小的，当最后期限相同时则为最先添加</span></span><br><span class="line">    <span class="comment"># 到self._timeouts的</span></span><br><span class="line">    heapq.heappush(self._timeouts, timeout)</span><br><span class="line">    <span class="keyword">return</span> timeout</span><br></pre></td></tr></table></figure></li></ul><p>执行该函数之后timeouts就会被添加到self._timeouts中，当tornado IOLoop的epoll.poll()函数再次醒来时，则会重新迭代，然后调用self._timeouts，进行相关判断处理。详解参考：<a href="../tornado_ioloop#start">tornado ioloop解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-PeriodicCallback&quot;&gt;&lt;a href=&quot;#tornado-PeriodicCallback&quot; class=&quot;headerlink&quot; title=&quot;tornado PeriodicCallback&quot;&gt;&lt;/a&gt;tornado PeriodicCallback&lt;/h2&gt;&lt;p&gt;tornado.ioloop.PeriodicCallback是tornado实现的定时器。&lt;/p&gt;
   &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tornado.web.Application)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handlers = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, HomeHandler),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        settings = dict(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            debug=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(Application, self).__init__(handlers, **settings)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="PeriodicCallback" scheme="http://yoursite.com/tags/PeriodicCallback/"/>
    
      <category term="定时器" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>tornado gen实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_gen/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_gen/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2018-04-03T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-gen"><a href="#tornado-gen" class="headerlink" title="tornado gen"></a>tornado gen</h2><p>tornado.gen是一个基于生成器的接口，可以更容易地在异步环境中工作。使用gen模块的代码在技术上是异步的，但它被写成一个单独的生成器，而不是另外的函数集合。</p><a id="more"></a><ul><li><p><div id="with_timeout"></div>tornado.gen.with_timeout()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_timeout</span><span class="params">(timeout, future, io_loop=None, quiet_exceptions=<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 在超时时间内封装Future对象</span></span><br><span class="line">    <span class="comment"># 如果传入的future在超时之前没有完成，则引发TimeoutError，可以通过</span></span><br><span class="line">    <span class="comment"># .IOLoop.add_timeout（即datetime.timedelta或者相对于.IOLoop.time的绝对</span></span><br><span class="line">    <span class="comment"># 时间）允许的任何形式来指定。</span></span><br><span class="line">    <span class="comment"># 如果封装的Future在超时之后失败，则将记录该异常，除非它是“quiet_exceptions”</span></span><br><span class="line">    <span class="comment"># （可能是一个异常类型或一系列类型）中包含的类型。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将一个yielded对象转换为一个Future</span></span><br><span class="line">    future = convert_yielded(future)</span><br><span class="line">    <span class="comment"># 初始化一个新的Future对象</span></span><br><span class="line">    result = Future()</span><br><span class="line">    <span class="comment"># 将新的Future对象与待处理的future关联，用于超时处理、结果处理</span></span><br><span class="line">    chain_future(future, result)</span><br><span class="line">    <span class="keyword">if</span> io_loop <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        io_loop = IOLoop.current()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># future超时处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error_callback</span><span class="params">(future)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(e, quiet_exceptions):</span><br><span class="line">                app_log.error(<span class="string">"Exception in Future %r after timeout"</span>,</span><br><span class="line">                              future, exc_info=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># IOLoop超时回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeout_callback</span><span class="params">()</span>:</span></span><br><span class="line">        result.set_exception(TimeoutError(<span class="string">"Timeout"</span>))</span><br><span class="line">        <span class="comment"># In case the wrapped future goes on to fail, log it.</span></span><br><span class="line">        future.add_done_callback(error_callback)</span><br><span class="line">    <span class="comment"># 添加超时事件到IOLoop</span></span><br><span class="line">    timeout_handle = io_loop.add_timeout(</span><br><span class="line">        timeout, timeout_callback)</span><br><span class="line">    <span class="comment"># 根据future不同类型，分别处理删除IOLoop中future的超时回调事件</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(future, Future):</span><br><span class="line">        <span class="comment"># We know this future will resolve on the IOLoop, so we don't</span></span><br><span class="line">        <span class="comment"># need the extra thread-safety of IOLoop.add_future (and we also</span></span><br><span class="line">        <span class="comment"># don't care about StackContext here.</span></span><br><span class="line">        future.add_done_callback(</span><br><span class="line">            <span class="keyword">lambda</span> future: io_loop.remove_timeout(timeout_handle))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># concurrent.futures.Futures may resolve on any thread, so we</span></span><br><span class="line">        <span class="comment"># need to route them back to the IOLoop.</span></span><br><span class="line">        io_loop.add_future(</span><br><span class="line">            future, <span class="keyword">lambda</span> future: io_loop.remove_timeout(timeout_handle))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><p>首先会初始化一个Future对象，用于获取结果，即result。然后调用chain_future将future与result对象绑定，参考详解：<a href="../tornado_concurrent#chain_future">tornado concurrent解析</a>。接着会注册超时事件到IOLoop，具体参考详解：<a href="../tornado_ioloop_PeriodicCallback#add_timeout">tornado定时器PeriodicCallback解析</a>。如果timeout超时了，则IOLoop会调用timeout_callback，然后result调用set_exception抛出异常，并终止Future，即设置self._done为True；future也同样抛出异常，会将异常写入日志中。如果在timeout超时之前future操作成功完成，则会将其返回数据写到result中，并删除注册到IOLoop中的超时回调事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-gen&quot;&gt;&lt;a href=&quot;#tornado-gen&quot; class=&quot;headerlink&quot; title=&quot;tornado gen&quot;&gt;&lt;/a&gt;tornado gen&lt;/h2&gt;&lt;p&gt;tornado.gen是一个基于生成器的接口，可以更容易地在异步环境中工作。使用gen模块的代码在技术上是异步的，但它被写成一个单独的生成器，而不是另外的函数集合。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="gen" scheme="http://yoursite.com/tags/gen/"/>
    
  </entry>
  
  <entry>
    <title>tornado iostream实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_iostream/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_iostream/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2018-04-03T03:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-iostream"><a href="#tornado-iostream" class="headerlink" title="tornado iostream"></a>tornado iostream</h2><p>封装了对socket fd底层数据的读取、写入操作，针对不同的情况实现了几种不同的读取方式。</p><a id="more"></a><ul><li><p><div id="read_until_regex"></div>tornado.iostream.BaseIOStream.read_until_regex()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_until_regex</span><span class="params">(self, regex, callback=None, max_bytes=None)</span>:</span></span><br><span class="line">    <span class="comment"># 设置读取完成后的回调函数</span></span><br><span class="line">    future = self._set_read_callback(callback)</span><br><span class="line">    <span class="comment"># 编译正则表达式，并保存到self._read_regex</span></span><br><span class="line">    self._read_regex = re.compile(regex)</span><br><span class="line">    <span class="comment"># 保存最大读取数据长度到self._read_max_bytes</span></span><br><span class="line">    self._read_max_bytes = max_bytes</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self._try_inline_read()</span><br><span class="line">    <span class="keyword">except</span> UnsatisfiableReadError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># Handle this the same way as in _handle_events.</span></span><br><span class="line">        gen_log.info(<span class="string">"Unsatisfiable read, closing connection: %s"</span> % e)</span><br><span class="line">        self.close(exc_info=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">if</span> future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># Ensure that the future doesn't log an error because its</span></span><br><span class="line">            <span class="comment"># failure was never examined.</span></span><br><span class="line">            future.add_done_callback(<span class="keyword">lambda</span> f: f.exception())</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure></li></ul><p>通过正则表达式匹配客户端发来的数据，http协议规定了数据结构，每行数据后面都会有一个CRLF，而请求行与请求头数据结尾也会有一个CRLF，即请求头数据后面有两个CRLF，请求体也是如此。CRLF即为回车（Carriage-Return，CR，\r）、换行（Line-Feed，LF,\n）。Windows下CRLF表示：\r\n；Unix下CRLF表示：\n。tornado.http1connection.HTTP1Connection._read_message()方法调用本方法传入的regex参数为”\r?\n\r?\n”，刚好兼容了Windows和Unix。</p><ul><li><p>tornado.iostream.BaseIOStream._set_read_callback()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_read_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> self._read_callback <span class="keyword">is</span> <span class="keyword">None</span>, <span class="string">"Already reading"</span></span><br><span class="line">    <span class="keyword">assert</span> self._read_future <span class="keyword">is</span> <span class="keyword">None</span>, <span class="string">"Already reading"</span></span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self._read_callback = stack_context.wrap(callback)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._read_future = TracebackFuture()</span><br><span class="line">    <span class="keyword">return</span> self._read_future</span><br></pre></td></tr></table></figure></li></ul><p>通过read_until_regex方法读取请求数据时，是没有callback的，即callback为None，所以_set_read_callback会返回一个Future对象实例，用于返回异步执行结果。</p><ul><li><p>tornado.iostream.BaseIOStream._try_inline_read()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_try_inline_read</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 尝试从缓存数据中完成当前读操作。</span></span><br><span class="line">    <span class="comment"># 如果此次读操作能在无阻塞的情况下完成，则在下次IOLoop迭代中执行读回调函数，</span></span><br><span class="line">    <span class="comment"># 否则为此次读事件在套接字上启动监听</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看是否从前一次的读操作中获取到了数据</span></span><br><span class="line">    <span class="comment"># 第一部分</span></span><br><span class="line">    self._run_streaming_callback()</span><br><span class="line">    pos = self._find_read_pos()</span><br><span class="line">    <span class="keyword">if</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self._read_from_buffer(pos)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 第二部分</span></span><br><span class="line">    self._check_closed()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pos = self._read_to_buffer_loop()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="comment"># If there was an in _read_to_buffer, we called close() already,</span></span><br><span class="line">        <span class="comment"># but couldn't run the close callback because of _pending_callbacks.</span></span><br><span class="line">        <span class="comment"># Before we escape from this function, run the close callback if</span></span><br><span class="line">        <span class="comment"># applicable.</span></span><br><span class="line">        self._maybe_run_close_callback()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">if</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self._read_from_buffer(pos)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 第三部分</span></span><br><span class="line">    <span class="comment"># We couldn't satisfy the read inline, so either close the stream</span></span><br><span class="line">    <span class="comment"># or listen for new data.</span></span><br><span class="line">    <span class="keyword">if</span> self.closed():</span><br><span class="line">        self._maybe_run_close_callback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._add_io_state(ioloop.IOLoop.READ)</span><br></pre></td></tr></table></figure></li><li><p>方法可以分为三部分：<br>  第一部分：首先会去检测前一次是否将数据读取到了缓存，即通过self._find_read_pos()获取到的pos是否为None，如果不为None，则表示已经读取数据完成（读取到足够大小的数据：max_bytes参数、正则表达式匹配成功：regex参数，或者遇到指定的分隔符：read_until()方法中的delimiter参数），然后调用self._read_from_buffer(pos)将_read_future加入IOLoop；</p><p>  第二部分：调用self._read_to_buffer_loop()循环读取请求数据，方法中封装了第一部分的部分操作，接下来与第一部分操作一致；</p><p>  第三部分：判断该stream连接是否断开，如果已经断开调用关闭回调函数，否则将该连接再次放到IOLoop中，继续读取数据。</p></li><li><p>tornado.iostream.BaseIOStream._find_read_pos()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_read_pos</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 试图在读取缓冲区中找到满足当前待读取的位置</span></span><br><span class="line">    <span class="comment"># 如果能够满足当前读取，则返回缓冲区中的位置;如果不能，则返回None。</span></span><br><span class="line">    <span class="keyword">if</span> (self._read_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></span><br><span class="line">        (self._read_buffer_size &gt;= self._read_bytes <span class="keyword">or</span></span><br><span class="line">         (self._read_partial <span class="keyword">and</span> self._read_buffer_size &gt; <span class="number">0</span>))):</span><br><span class="line">        num_bytes = min(self._read_bytes, self._read_buffer_size)</span><br><span class="line">        <span class="keyword">return</span> num_bytes</span><br><span class="line">    <span class="keyword">elif</span> self._read_delimiter <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># Multi-byte delimiters (e.g. '\r\n') may straddle two</span></span><br><span class="line">        <span class="comment"># chunks in the read buffer, so we can't easily find them</span></span><br><span class="line">        <span class="comment"># without collapsing the buffer.  However, since protocols</span></span><br><span class="line">        <span class="comment"># using delimited reads (as opposed to reads of a known</span></span><br><span class="line">        <span class="comment"># length) tend to be "line" oriented, the delimiter is likely</span></span><br><span class="line">        <span class="comment"># to be in the first few chunks.  Merge the buffer gradually</span></span><br><span class="line">        <span class="comment"># since large merges are relatively expensive and get undone in</span></span><br><span class="line">        <span class="comment"># _consume().</span></span><br><span class="line">        <span class="keyword">if</span> self._read_buffer:</span><br><span class="line">            loc = self._read_buffer.find(self._read_delimiter,</span><br><span class="line">                                         self._read_buffer_pos)</span><br><span class="line">            <span class="keyword">if</span> loc != <span class="number">-1</span>:</span><br><span class="line">                loc -= self._read_buffer_pos</span><br><span class="line">                delimiter_len = len(self._read_delimiter)</span><br><span class="line">                self._check_max_bytes(self._read_delimiter,</span><br><span class="line">                                      loc + delimiter_len)</span><br><span class="line">                <span class="keyword">return</span> loc + delimiter_len</span><br><span class="line">            self._check_max_bytes(self._read_delimiter,</span><br><span class="line">                                  self._read_buffer_size)</span><br><span class="line">    <span class="keyword">elif</span> self._read_regex <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># self._read_buffer在_read_to_buffer方法中定义</span></span><br><span class="line">        <span class="keyword">if</span> self._read_buffer:</span><br><span class="line">            <span class="comment"># 在已读取的数据中从上一次的位置开始匹配正则，self._read_buffer_pos在</span></span><br><span class="line">            <span class="comment"># _consume方法中定义</span></span><br><span class="line">            m = self._read_regex.search(self._read_buffer,</span><br><span class="line">                                        self._read_buffer_pos)</span><br><span class="line">            <span class="comment"># 匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="comment"># 获取本次读取的数据大小</span></span><br><span class="line">                loc = m.end() - self._read_buffer_pos</span><br><span class="line">                <span class="comment"># 判断本次读取的数据是否超过了最大读取数据量，如果是则</span></span><br><span class="line">                <span class="comment"># 报错UnsatisfiableReadError</span></span><br><span class="line">                self._check_max_bytes(self._read_regex, loc)</span><br><span class="line">                <span class="keyword">return</span> loc</span><br><span class="line">            <span class="comment"># 如果没有匹配到正则表达式，则检查读取的数据量是否超过了最大读取数据量</span></span><br><span class="line">            <span class="comment"># self._read_buffer_size在_read_to_buffer方法中定义</span></span><br><span class="line">            self._check_max_bytes(self._read_regex, self._read_buffer_size)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></li></ul><p>在read_until_regex()方法中，self._read_regex是存在的，self._read_delimiter是针对read_until()方法的操作。在此方法中可知，传入read_until_regex()的max_bytes必须要大于self.read_chunk_size（socket.recv每次循环接收的数据量），否则会直接报错。</p><ul><li><p>tornado.iostream.BaseIOStream._read_to_buffer_loop()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_to_buffer_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># This method is called from _handle_read and _try_inline_read.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据不同的方法调用获取对应的目标数据量</span></span><br><span class="line">        <span class="keyword">if</span> self._read_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            target_bytes = self._read_bytes</span><br><span class="line">        <span class="keyword">elif</span> self._read_max_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            target_bytes = self._read_max_bytes</span><br><span class="line">        <span class="keyword">elif</span> self.reading():</span><br><span class="line">            <span class="comment"># 对于没有max_bytes参数的read_until或者read_until_close，应在扫描分</span></span><br><span class="line">            <span class="comment"># 隔符之前尽可能多地进行读取。</span></span><br><span class="line">            target_bytes = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_bytes = <span class="number">0</span></span><br><span class="line">        next_find_pos = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 假装有一个挂起的回调，以便_read_to_buffer中的EOF不会触发立即关闭回调。 </span></span><br><span class="line">        <span class="comment"># 在这个方法（_try_inline_read）的最后，我们要么通过_read_from_buffer</span></span><br><span class="line">        <span class="comment"># 建立一个真正的等待回调，要么运行关闭回调。避免程序中途退出。因为</span></span><br><span class="line">        <span class="comment"># 在_maybe_run_close_callback、_maybe_add_error_listener等方法中都</span></span><br><span class="line">        <span class="comment"># 会比较self._pending_callbacks参数值，如果该值不为0，则表示该loop过程</span></span><br><span class="line">        <span class="comment"># 还在执行，不能去运行关闭回调。最后的finally块中会递减该值。</span></span><br><span class="line">        self._pending_callbacks += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.closed():</span><br><span class="line">            <span class="comment"># 从socket中读数据，直到得到EWOULDBLOCK（当一个非阻塞的操作没有数据</span></span><br><span class="line">            <span class="comment"># 操作时，如读操作时，缓存区空了，此时没有数据读了，写操作时，缓存区已</span></span><br><span class="line">            <span class="comment"># 满，无法再写入）或者类似的错误。在Windows上为EWOULDBLOCK，Linux</span></span><br><span class="line">            <span class="comment"># 上为EAGAIN</span></span><br><span class="line">            <span class="keyword">if</span> self._read_to_buffer() == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            self._run_streaming_callback()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果已经读完了所有可以使用的字节，就跳出这个循环。不能在</span></span><br><span class="line">            <span class="comment"># 这里调用read_from_buffer，因为它与pending_callback和</span></span><br><span class="line">            <span class="comment"># error_listener机制的微妙交互。</span></span><br><span class="line">            <span class="comment"># 如果已经达到target_bytes，则已经读取完成了。</span></span><br><span class="line">            <span class="keyword">if</span> (target_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></span><br><span class="line">                    self._read_buffer_size &gt;= target_bytes):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 否则，需要调用更加昂贵的find_read_pos。 在每次读取时这样做</span></span><br><span class="line">            <span class="comment"># 效率不高，所以在第一次读取以及每当读取缓冲区大小加倍时都要这样做。</span></span><br><span class="line">            <span class="keyword">if</span> self._read_buffer_size &gt;= next_find_pos:</span><br><span class="line">                pos = self._find_read_pos()</span><br><span class="line">                <span class="keyword">if</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> pos</span><br><span class="line">                next_find_pos = self._read_buffer_size * <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self._find_read_pos()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 递减该属性值，以便能执行关闭回调等操作</span></span><br><span class="line">        self._pending_callbacks -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p>读取底层socket fd中的数据，将其保存到缓存中。通过判断该socket连接是否断开进行循环读取操作，最主要的就是self._read_to_buffer()方法，封装了对socket中读取到的数据处理过程。最终会调用socket原生的读取函数socket.recv(buffer)，即read_from_fd()函数，此函数在IOStream中被实现。</p><ul><li><p>tornado.iostream.BaseIOStream._read_from_buffer()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_from_buffer</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">    <span class="comment"># 尝试从缓冲区中完成当前正在等待的读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重置参数</span></span><br><span class="line">    self._read_bytes = self._read_delimiter = self._read_regex = <span class="keyword">None</span></span><br><span class="line">    self._read_partial = <span class="keyword">False</span></span><br><span class="line">    self._run_read_callback(pos, <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>tornado.iostream.BaseIOStream._run_read_callback()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_read_callback</span><span class="params">(self, size, streaming)</span>:</span></span><br><span class="line">    <span class="comment"># 判断是否要运行stream回调函数，read_until_regex没有该函数</span></span><br><span class="line">    <span class="keyword">if</span> streaming:</span><br><span class="line">        callback = self._streaming_callback</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        callback = self._read_callback</span><br><span class="line">        self._read_callback = self._streaming_callback = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 如果self._read_future不为空</span></span><br><span class="line">        <span class="keyword">if</span> self._read_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">assert</span> callback <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">            future = self._read_future</span><br><span class="line">            self._read_future = <span class="keyword">None</span></span><br><span class="line">            future.set_result(self._consume(size))</span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> (self._read_future <span class="keyword">is</span> <span class="keyword">None</span>) <span class="keyword">or</span> streaming</span><br><span class="line">        self._run_callback(callback, self._consume(size))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># If we scheduled a callback, we will add the error listener</span></span><br><span class="line">        <span class="comment"># afterwards.  If we didn't, we have to do it now.</span></span><br><span class="line">        self._maybe_add_error_listener()</span><br></pre></td></tr></table></figure></li></ul><p>首先通过streaming参数，决定callback是何值。streaming参数针对read_bytes、read_until_close这两个读取方法，而read_until、read_until_regex没有streaming_callback。针对没有streaming_callback的方法，会判断self._read_callback和self._read_future，如果self._read_future不会空，则会使用Future对象将数据返回，否则通过callback回调返回。Future详解参考：<a href="../tornado_concurrent">tornado concurrent解析</a></p><ul><li><p>tornado.iostream.BaseIOStream._consume()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_consume</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">    <span class="comment"># 消耗缓存区的loc数量数据，并将其返回</span></span><br><span class="line">    <span class="keyword">if</span> loc == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b""</span></span><br><span class="line">    <span class="keyword">assert</span> loc &lt;= self._read_buffer_size</span><br><span class="line">    <span class="comment"># 获取已读取到缓存区的总数据self._read_buffer，并截取其中从位置</span></span><br><span class="line">    <span class="comment"># self._read_buffer_pos（最开始为0）到self._read_buffer_pos + loc</span></span><br><span class="line">    <span class="comment"># 中的数据</span></span><br><span class="line">    b = (memoryview(self._read_buffer)</span><br><span class="line">         [self._read_buffer_pos:self._read_buffer_pos + loc]</span><br><span class="line">         ).tobytes()</span><br><span class="line">    self._read_buffer_pos += loc</span><br><span class="line">    self._read_buffer_size -= loc</span><br><span class="line">    <span class="comment"># Amortized O(1) shrink</span></span><br><span class="line">    <span class="comment"># (this heuristic is implemented natively in Python 3.4+</span></span><br><span class="line">    <span class="comment">#  but is replicated here for Python 2)</span></span><br><span class="line">    <span class="keyword">if</span> self._read_buffer_pos &gt; self._read_buffer_size:</span><br><span class="line">        <span class="keyword">del</span> self._read_buffer[:self._read_buffer_pos]</span><br><span class="line">        self._read_buffer_pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-iostream&quot;&gt;&lt;a href=&quot;#tornado-iostream&quot; class=&quot;headerlink&quot; title=&quot;tornado iostream&quot;&gt;&lt;/a&gt;tornado iostream&lt;/h2&gt;&lt;p&gt;封装了对socket fd底层数据的读取、写入操作，针对不同的情况实现了几种不同的读取方式。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="iostream" scheme="http://yoursite.com/tags/iostream/"/>
    
  </entry>
  
  <entry>
    <title>tornado application实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_application/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_application/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2018-04-02T10:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-application"><a href="#tornado-application" class="headerlink" title="tornado application"></a>tornado application</h2><p>tornado.web.Application继承结构为：ReversibleRouter ——&gt; Router ——&gt; httputil.HTTPServerConnectionDelegate</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-application&quot;&gt;&lt;a href=&quot;#tornado-application&quot; class=&quot;headerlink&quot; title=&quot;tornado application&quot;&gt;&lt;/a&gt;tornado application&lt;/h2&gt;&lt;p&gt;tornado.web.Application继承结构为：ReversibleRouter ——&amp;gt; Router ——&amp;gt; httputil.HTTPServerConnectionDelegate&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="application" scheme="http://yoursite.com/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>tornado http1connection实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_http1connection/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_http1connection/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2018-04-03T03:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-http1connection"><a href="#tornado-http1connection" class="headerlink" title="tornado http1connection"></a>tornado http1connection</h2><p>tornado http1connection主要是对http协议进行了封装。</p><a id="more"></a><ul><li><p><div id="start_serving"></div>tornado.http1connection.HTTP1ServerConnection.start_serving()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_serving</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    <span class="comment"># 这里断言delegate是httputil.HTTPServerConnectionDelegate的实例</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(delegate, httputil.HTTPServerConnectionDelegate)</span><br><span class="line">    self._serving_future = self._server_request_loop(delegate)</span><br><span class="line">    self.stream.io_loop.add_future(self._serving_future,</span><br><span class="line">                                   <span class="keyword">lambda</span> f: f.result())</span><br></pre></td></tr></table></figure></li></ul><p>开始处理这个连接上的请求，在tornado.HTTPServer.handle_stream()中调用此方法，传入的参数为HTTPServer的实例，即delegate为HTTPServer实例，由于HTTPServer继承至httputil.HTTPServerConnectionDelegate，所以断言成功，程序开始执行self._server_request_loop()。</p><ul><li><p>tornado.http1connection.HTTP1ServerConnection._server_request_loop()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_server_request_loop</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 初始化HTTP1Connection实例</span></span><br><span class="line">            conn = HTTP1Connection(self.stream, <span class="keyword">False</span>,</span><br><span class="line">                                   self.params, self.context)</span><br><span class="line">            <span class="comment"># 调用delegate的start_request处理连接请求</span></span><br><span class="line">            request_delegate = delegate.start_request(self, conn)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 读取http响应</span></span><br><span class="line">                ret = <span class="keyword">yield</span> conn.read_response(request_delegate)</span><br><span class="line">            <span class="keyword">except</span> (iostream.StreamClosedError,</span><br><span class="line">                    iostream.UnsatisfiableReadError):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">except</span> _QuietException:</span><br><span class="line">                <span class="comment"># This exception was already logged.</span></span><br><span class="line">                conn.close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                gen_log.error(<span class="string">"Uncaught exception"</span>, exc_info=<span class="keyword">True</span>)</span><br><span class="line">                conn.close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 如果ret为false，则表示读取了完整的http响应</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">yield</span> gen.moment</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        delegate.on_close(self)v</span><br></pre></td></tr></table></figure></li></ul><p>方法中调用了delegate.start_request(self, conn)，即<a href="../tornado_httpserver#start_request">tornado.httpserver.HTTPServer.start_request()</a>，得到一个httputil.HTTPMessageDelegate实例，即request_delegate。接下来开始读取响应数据。</p><ul><li><p>tornado.http1connection.HTTP1Connection.read_response()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_response</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    <span class="comment"># 判断是否需要解压缩数据</span></span><br><span class="line">    <span class="keyword">if</span> self.params.decompress:</span><br><span class="line">        delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)</span><br><span class="line">    <span class="keyword">return</span> self._read_message(delegate)</span><br></pre></td></tr></table></figure></li><li><p>tornado.http1connection.HTTP1Connection._read_message()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_message</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    need_delegate_close = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 读取请求header数据，返回Future对象</span></span><br><span class="line">        header_future = self.stream.read_until_regex(</span><br><span class="line">            <span class="string">b"\r?\n\r?\n"</span>,</span><br><span class="line">            max_bytes=self.params.max_header_size)</span><br><span class="line">        <span class="comment"># 判断header_timeout是否为None，如果为None，则直接读取header_future数据</span></span><br><span class="line">        <span class="keyword">if</span> self.params.header_timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            header_data = <span class="keyword">yield</span> header_future</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># header超时实现</span></span><br><span class="line">                header_data = <span class="keyword">yield</span> gen.with_timeout(</span><br><span class="line">                    self.stream.io_loop.time() + self.params.header_timeout,</span><br><span class="line">                    header_future,</span><br><span class="line">                    io_loop=self.stream.io_loop,</span><br><span class="line">                    quiet_exceptions=iostream.StreamClosedError)</span><br><span class="line">            <span class="keyword">except</span> gen.TimeoutError:</span><br><span class="line">                self.close()</span><br><span class="line">                <span class="keyword">raise</span> gen.Return(<span class="keyword">False</span>)</span><br><span class="line">        <span class="comment"># 解析header信息，HTTP协议分为request-line、request-header、</span></span><br><span class="line">        <span class="comment"># request-body三个部分的。在查看各浏览器、服务器配置的时候往往将</span></span><br><span class="line">        <span class="comment"># request-line、request-header归为一类了</span></span><br><span class="line">        start_line, headers = self._parse_headers(header_data)</span><br><span class="line">        <span class="comment"># 判断是否作为客户端</span></span><br><span class="line">        <span class="keyword">if</span> self.is_client:</span><br><span class="line">            <span class="comment"># 如果作为客户端，则解析服务端响应起始行</span></span><br><span class="line">            start_line = httputil.parse_response_start_line(start_line)</span><br><span class="line">            self._response_start_line = start_line</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果作为服务端，则解析客户端请求起始行</span></span><br><span class="line">            start_line = httputil.parse_request_start_line(start_line)</span><br><span class="line">            self._request_start_line = start_line</span><br><span class="line">            self._request_headers = headers</span><br><span class="line">        <span class="comment"># 判断是否能保持长链接，即Connection: keep_alive</span></span><br><span class="line">        self._disconnect_on_finish = <span class="keyword">not</span> self._can_keep_alive(</span><br><span class="line">            start_line, headers)</span><br><span class="line">        need_delegate_close = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">            header_future = delegate.headers_received(start_line, headers)</span><br><span class="line">            <span class="keyword">if</span> header_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> header_future</span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># We've been detached.</span></span><br><span class="line">            need_delegate_close = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">raise</span> gen.Return(<span class="keyword">False</span>)</span><br><span class="line">        skip_body = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.is_client:</span><br><span class="line">            <span class="keyword">if</span> (self._request_start_line <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></span><br><span class="line">                    self._request_start_line.method == <span class="string">'HEAD'</span>):</span><br><span class="line">                skip_body = <span class="keyword">True</span></span><br><span class="line">            code = start_line.code</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">304</span>:</span><br><span class="line">                <span class="comment"># 304 responses may include the content-length header</span></span><br><span class="line">                <span class="comment"># but do not actually have a body.</span></span><br><span class="line">                <span class="comment"># http://tools.ietf.org/html/rfc7230#section-3.3</span></span><br><span class="line">                skip_body = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> code &gt;= <span class="number">100</span> <span class="keyword">and</span> code &lt; <span class="number">200</span>:</span><br><span class="line">                <span class="comment"># 1xx responses should never indicate the presence of</span></span><br><span class="line">                <span class="comment"># a body.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'Content-Length'</span> <span class="keyword">in</span> headers <span class="keyword">or</span></span><br><span class="line">                        <span class="string">'Transfer-Encoding'</span> <span class="keyword">in</span> headers):</span><br><span class="line">                    <span class="keyword">raise</span> httputil.HTTPInputError(</span><br><span class="line">                        <span class="string">"Response code %d cannot have body"</span> % code)</span><br><span class="line">                <span class="comment"># <span class="doctag">TODO:</span> client delegates will get headers_received twice</span></span><br><span class="line">                <span class="comment"># in the case of a 100-continue.  Document or change?</span></span><br><span class="line">                <span class="keyword">yield</span> self._read_message(delegate)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (headers.get(<span class="string">"Expect"</span>) == <span class="string">"100-continue"</span> <span class="keyword">and</span></span><br><span class="line">                    <span class="keyword">not</span> self._write_finished):</span><br><span class="line">                self.stream.write(<span class="string">b"HTTP/1.1 100 (Continue)\r\n\r\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> skip_body:</span><br><span class="line">            body_future = self._read_body(</span><br><span class="line">                start_line.code <span class="keyword">if</span> self.is_client <span class="keyword">else</span> <span class="number">0</span>, headers, delegate)</span><br><span class="line">            <span class="keyword">if</span> body_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> self._body_timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> body_future</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="keyword">yield</span> gen.with_timeout(</span><br><span class="line">                            self.stream.io_loop.time() + self._body_timeout,</span><br><span class="line">                            body_future, self.stream.io_loop,</span><br><span class="line">                            quiet_exceptions=iostream.StreamClosedError)</span><br><span class="line">                    <span class="keyword">except</span> gen.TimeoutError:</span><br><span class="line">                        gen_log.info(<span class="string">"Timeout reading body from %s"</span>,</span><br><span class="line">                                     self.context)</span><br><span class="line">                        self.stream.close()</span><br><span class="line">                        <span class="keyword">raise</span> gen.Return(<span class="keyword">False</span>)</span><br><span class="line">        self._read_finished = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._write_finished <span class="keyword">or</span> self.is_client:</span><br><span class="line">            need_delegate_close = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">                delegate.finish()</span><br><span class="line">        <span class="comment"># If we're waiting for the application to produce an asynchronous</span></span><br><span class="line">        <span class="comment"># response, and we're not detached, register a close callback</span></span><br><span class="line">        <span class="comment"># on the stream (we didn't need one while we were reading)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> self._finish_future.done() <span class="keyword">and</span></span><br><span class="line">                self.stream <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></span><br><span class="line">                <span class="keyword">not</span> self.stream.closed()):</span><br><span class="line">            self.stream.set_close_callback(self._on_connection_close)</span><br><span class="line">            <span class="keyword">yield</span> self._finish_future</span><br><span class="line">        <span class="keyword">if</span> self.is_client <span class="keyword">and</span> self._disconnect_on_finish:</span><br><span class="line">            self.close()</span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> gen.Return(<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">except</span> httputil.HTTPInputError <span class="keyword">as</span> e:</span><br><span class="line">        gen_log.info(<span class="string">"Malformed HTTP message from %s: %s"</span>,</span><br><span class="line">                     self.context, e)</span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">raise</span> gen.Return(<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> need_delegate_close:</span><br><span class="line">            <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">                delegate.on_connection_close()</span><br><span class="line">        header_future = <span class="keyword">None</span></span><br><span class="line">        self._clear_callbacks()</span><br><span class="line">    <span class="keyword">raise</span> gen.Return(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></li></ul><p>重要方法，首先会调用stream的read_until_regex方法开始读取客户端请求传入的头数据（http协议的header），返回一个Future对象，即header_future，详解参考：<a href="../tornado_iostream#read_until_regex">tornado iostream解析</a>；接着会判断是否有设置header_timeout，而在该方法中，默认是3600秒，则开始请求头超时机制设计，详解参考：<a href="../tornado_gen#with_timeout">tornado gen解析</a>；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-http1connection&quot;&gt;&lt;a href=&quot;#tornado-http1connection&quot; class=&quot;headerlink&quot; title=&quot;tornado http1connection&quot;&gt;&lt;/a&gt;tornado http1connection&lt;/h2&gt;&lt;p&gt;tornado http1connection主要是对http协议进行了封装。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="http1connection" scheme="http://yoursite.com/tags/http1connection/"/>
    
  </entry>
  
  <entry>
    <title>tornado netutil实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_netutil/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_netutil/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2018-04-02T10:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-netutil"><a href="#tornado-netutil" class="headerlink" title="tornado netutil"></a>tornado netutil</h2><ul><li><div id="bind_sockets"></div>tornado.netutil.bind_sockets()</li></ul><p>该方法创建绑定到给定端口和地址的监听套接字socket。返回套接字对象的列表，比如给定的address参数映射到多个IP地址，则返回多个socket，最常见的是混合使用IPv4与IPv6，则会创建对应的两个socket。</p><a id="more"></a>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_sockets</span><span class="params">(port, address=None, family=socket.AF_UNSPEC,</span></span></span><br><span class="line"><span class="function"><span class="params">             backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当设置了端口复用时，会检查系统是否支持端口复用功能</span></span><br><span class="line">    <span class="keyword">if</span> reuse_port <span class="keyword">and</span> <span class="keyword">not</span> hasattr(socket, <span class="string">"SO_REUSEPORT"</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"the platform doesn't support SO_REUSEPORT"</span>)</span><br><span class="line"></span><br><span class="line">    sockets = []</span><br><span class="line">    <span class="keyword">if</span> address == <span class="string">""</span>:</span><br><span class="line">        address = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 如果系统不支持IPv6并且参数family为AF_UNSPEC，则family选择IPv4协议</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> socket.has_ipv6 <span class="keyword">and</span> family == socket.AF_UNSPEC:</span><br><span class="line">        family = socket.AF_INET</span><br><span class="line">    <span class="keyword">if</span> flags <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        flags = socket.AI_PASSIVE</span><br><span class="line">    bound_port = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 循环遍历获取的地址信息</span></span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,</span><br><span class="line">                                      <span class="number">0</span>, flags)):</span><br><span class="line">        af, socktype, proto, canonname, sockaddr = res</span><br><span class="line">        <span class="comment">#　排除另类数据</span></span><br><span class="line">        <span class="keyword">if</span> (sys.platform == <span class="string">'darwin'</span> <span class="keyword">and</span> address == <span class="string">'localhost'</span> <span class="keyword">and</span></span><br><span class="line">                af == socket.AF_INET6 <span class="keyword">and</span> sockaddr[<span class="number">3</span>] != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 创建socket对象</span></span><br><span class="line">            sock = socket.socket(af, socktype, proto)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(e) == errno.EAFNOSUPPORT:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="comment"># 设置close-on-exec标志位</span></span><br><span class="line">        set_close_exec(sock.fileno())</span><br><span class="line">        <span class="comment"># 设置SO_REUSEADDR</span></span><br><span class="line">        <span class="keyword">if</span> os.name != <span class="string">'nt'</span>:</span><br><span class="line">            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">#　设置SO_REUSEPORT</span></span><br><span class="line">        <span class="keyword">if</span> reuse_port:</span><br><span class="line">            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> af == socket.AF_INET6:</span><br><span class="line">            <span class="comment"># 在linux上，ipv6 socket也默认接受ipv4，但是这样就无法绑定到ipv4</span></span><br><span class="line">            <span class="comment"># 中的0.0.0.0和ipv6中的::。 </span></span><br><span class="line">            <span class="comment"># 在其他系统上，单独的套接字必须用于监听ipv4和ipv6。 </span></span><br><span class="line">            <span class="comment"># 为了保持一致性，请务必在ipv6套接字上禁用ipv4，并在需要时使用</span></span><br><span class="line">            <span class="comment"># 单独的ipv4套接字。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Windows上的Python 2.x没有IPPROTO_IPV6。</span></span><br><span class="line">            <span class="keyword">if</span> hasattr(socket, <span class="string">"IPPROTO_IPV6"</span>):</span><br><span class="line">                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当port参数为None时，会自动分配绑定端口，该端口应同时绑定在IPv4和IPv6。</span></span><br><span class="line">        <span class="comment"># 当第一次循环时，bound_port会记录系统自动分配的port，然后应用到接下来的循环</span></span><br><span class="line">        host, requested_port = sockaddr[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> requested_port == <span class="number">0</span> <span class="keyword">and</span> bound_port <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            sockaddr = tuple([host, bound_port] + list(sockaddr[<span class="number">2</span>:]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置socket为非阻塞</span></span><br><span class="line">        sock.setblocking(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 绑定socket</span></span><br><span class="line">        sock.bind(sockaddr)</span><br><span class="line">        <span class="comment"># 记录下本次绑定的端口</span></span><br><span class="line">        bound_port = sock.getsockname()[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 开启socket监听</span></span><br><span class="line">        sock.listen(backlog)</span><br><span class="line">        sockets.append(sock)</span><br><span class="line">    <span class="keyword">return</span> sockets</span><br></pre></td></tr></table></figure><p>如上基本为socket的常规操作，主要操作放在了IPv4与IPv6的兼容方面。最终返回分别基于IPv4与IPv6两个socket对象组成的list。</p><ul><li><div id="add_accept_handler"></div>tornado.netutil.add_accept_handler()</li></ul><p>正是该方法将web服务器与IOLoop连接了起来，主要用于添加一个IOLoop事件处理器来接受服务器socket上的新连接（来自客户端的连接）。当一个客户端连接被accept，callback函数将会被调用。</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_accept_handler</span><span class="params">(sock, callback, io_loop=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> io_loop <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        io_loop = IOLoop.current()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_handler</span><span class="params">(fd, events)</span>:</span></span><br><span class="line">        <span class="comment"># 在我们处理回调时可能会有更多的连接; 为了防止其他任务的饥饿（如果该值过大，</span></span><br><span class="line">        <span class="comment"># 可能会导致程序执行当前队列时间过长，而后续任务无法被执行），我们必须限制</span></span><br><span class="line">        <span class="comment"># 我们一次接受的连接数。理想情况下，我们将接受输入此方法时等待的连接数，</span></span><br><span class="line">        <span class="comment"># 但是此信息不可用（而且在运行任何回调之前重新排列此方法以调用accept()</span></span><br><span class="line">        <span class="comment"># 多次可能会对多进程配置中的负载平衡产生不利影响）。 相反，我们使用（默认）</span></span><br><span class="line">        <span class="comment"># listen backlog作为我们可以合理接受的连接数的粗略启发式。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_DEFAULT_BACKLOG):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                connection, address = sock.accept()</span><br><span class="line">            <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># _ERRNO_WOULDBLOCK表示我们接受了每个有用的连接</span></span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) <span class="keyword">in</span> _ERRNO_WOULDBLOCK:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># ECONNABORTED表示有个链接已经被关闭了但任然在接受队列中</span></span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.ECONNABORTED:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="comment"># 调用callback</span></span><br><span class="line">            callback(connection, address)</span><br><span class="line">    <span class="comment"># 将服务器端sock以读事件注册到epoll，即epoll一直监听着服务器端socket，只要有</span></span><br><span class="line">    <span class="comment"># 客户端连接到服务器端socket，epoll就会触发，epoll.poll()方法就会返回，IOLoop</span></span><br><span class="line">    <span class="comment"># 就会调用accept_handler方法，最终调用callback(connection, address)</span></span><br><span class="line">    io_loop.add_handler(sock, accept_handler, IOLoop.READ)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-netutil&quot;&gt;&lt;a href=&quot;#tornado-netutil&quot; class=&quot;headerlink&quot; title=&quot;tornado netutil&quot;&gt;&lt;/a&gt;tornado netutil&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;div id=&quot;bind_sockets&quot;&gt;&lt;/div&gt;tornado.netutil.bind_sockets()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法创建绑定到给定端口和地址的监听套接字socket。返回套接字对象的列表，比如给定的address参数映射到多个IP地址，则返回多个socket，最常见的是混合使用IPv4与IPv6，则会创建对应的两个socket。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="netutil" scheme="http://yoursite.com/tags/netutil/"/>
    
  </entry>
  
  <entry>
    <title>tornado httpserver实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_httpserver/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_httpserver/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2018-04-03T03:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-httpserver"><a href="#tornado-httpserver" class="headerlink" title="tornado httpserver"></a>tornado httpserver</h2><p>tornado httpserver封装了对http请求的处理，是一个非阻塞、单线程的HTTP服务器。一个完整的web服务器示例如下，启动脚本后在浏览器访问<a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> ，页面会显示Hello，world：</p><a id="more"></a>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line"></span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8888</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 解析启动命令</span></span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    <span class="comment"># 创建Application示例</span></span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment"># 创建HTTPServer实例</span></span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(application)</span><br><span class="line">    <span class="comment"># 监听端口，创建服务器socket</span></span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    <span class="comment"># 获取IOLoop并启动</span></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>从实例中可以看到一个web服务器同时使用了tornado.httpserver.HTTPServer与tornado.ioloop.IOLoop，二者不可分离。</p><p>HTTPServer有三个父类：tornado.tcpserver.TCPServer、tornado.util.Configurable、<br>tornado.httputil.HTTPServerConnectionDelegate</p><p>当创建HTTPServer实例，即调用tornado.httpserver.HTTPServer(application)时，程序首先会调用tornado.util.Configurable.<strong>new</strong>()方法创建HTTPServer实例，对tornado.util.Configurable的详解可参考： <a href="../tornado_util_configurable">tornado配置类Configurable解析</a>，实例创建完成之后，会调用tornado.httpserver.HTTPServer.initialize()初始化参数配置。</p><ul><li><p>tornado.httpserver.HTTPServer.initialize()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, request_callback, no_keep_alive=False, io_loop=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               xheaders=False, ssl_options=None, protocol=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               decompress_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               chunk_size=None, max_header_size=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               idle_connection_timeout=None, body_timeout=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               max_body_size=None, max_buffer_size=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               trusted_downstream=None)</span>:</span></span><br><span class="line">    <span class="comment"># 由tornado.util.Configurable分析可知，self.request_callback为</span></span><br><span class="line">    <span class="comment"># tornado.web.Application实例</span></span><br><span class="line">    self.request_callback = request_callback</span><br><span class="line">    self.no_keep_alive = no_keep_alive</span><br><span class="line">    self.xheaders = xheaders</span><br><span class="line">    self.protocol = protocol</span><br><span class="line">    self.conn_params = HTTP1ConnectionParameters(</span><br><span class="line">        decompress=decompress_request,</span><br><span class="line">        chunk_size=chunk_size,</span><br><span class="line">        max_header_size=max_header_size,</span><br><span class="line">        header_timeout=idle_connection_timeout <span class="keyword">or</span> <span class="number">3600</span>,</span><br><span class="line">        max_body_size=max_body_size,</span><br><span class="line">        body_timeout=body_timeout,</span><br><span class="line">        no_keep_alive=no_keep_alive)</span><br><span class="line">    <span class="comment"># 调用TCPServer的初始化方法</span></span><br><span class="line">    TCPServer.__init__(self, io_loop=io_loop, ssl_options=ssl_options,</span><br><span class="line">                       max_buffer_size=max_buffer_size,</span><br><span class="line">                       read_chunk_size=chunk_size)</span><br><span class="line">    self._connections = set()</span><br><span class="line">    self.trusted_downstream = trusted_downstream</span><br></pre></td></tr></table></figure></li></ul><p>在开始的示例中实例化HTTPServer之后会执行：http_server.listen(options.port)，该代码会创建服务器socket，监听8888端口，socket详解可参考： <a href="../socket">socket解析</a>，listen()方法在tornado.tcpserver.TCPServer中实现。</p><ul><li><p>tornado.tcpserver.TCPServer.listen()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 调用bind_sockets</span></span><br><span class="line">    sockets = bind_sockets(port, address=address)</span><br><span class="line">    self.add_sockets(sockets)</span><br></pre></td></tr></table></figure></li></ul><p>listen()方法中就两行代码，分别调用了两个方法：tornado.netutil.bind_sockets()、add_sockets。tornado.netutil.bind_sockets()详解参考：<a href="../tornado_netutil#bind_sockets">tornado netutil解析</a></p><ul><li><p>tornado.tcpserver.TCPServer.add_sockets()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_sockets</span><span class="params">(self, sockets)</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前IOLoop对象，此时还没有start</span></span><br><span class="line">    <span class="keyword">if</span> self.io_loop <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        self.io_loop = IOLoop.current()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sock <span class="keyword">in</span> sockets:</span><br><span class="line">        <span class="comment"># 保存socket到self._sockets</span></span><br><span class="line">        self._sockets[sock.fileno()] = sock</span><br><span class="line">        <span class="comment"># 重点方法</span></span><br><span class="line">        add_accept_handler(sock, self._handle_connection,</span><br><span class="line">                           io_loop=self.io_loop)</span><br></pre></td></tr></table></figure></li></ul><p>add_sockets()方法最重要的是调用add_accept_handler()函数，详解参考：<a href="../tornado_netutil#add_accept_handler">tornado netutil解析</a>，从add_accept_handler()函数的详解可知，客户端连接到服务器之后的数据传输，最终调用self._handle_connection()方法完成。</p><ul><li><p>tornado.tcpserver.TCPServer._handle_connection()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_connection</span><span class="params">(self, connection, address)</span>:</span></span><br><span class="line">    <span class="comment"># 对ssl相关处理，可以略过</span></span><br><span class="line">    <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> ssl, <span class="string">"Python 2.6+ and OpenSSL required for SSL"</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            connection = ssl_wrap_socket(connection,</span><br><span class="line">                                         self.ssl_options,</span><br><span class="line">                                         server_side=<span class="keyword">True</span>,</span><br><span class="line">                                         do_handshake_on_connect=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">except</span> ssl.SSLError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="keyword">if</span> err.args[<span class="number">0</span>] == ssl.SSL_ERROR_EOF:</span><br><span class="line">                <span class="keyword">return</span> connection.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> err:</span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(err) <span class="keyword">in</span> (errno.ECONNABORTED, errno.EINVAL):</span><br><span class="line">                <span class="keyword">return</span> connection.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 如果是ssl连接，则使用SSLIOStream处理connection，否则使用IOStream</span></span><br><span class="line">        <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            stream = SSLIOStream(connection, io_loop=self.io_loop,</span><br><span class="line">                                 max_buffer_size=self.max_buffer_size,</span><br><span class="line">                                 read_chunk_size=self.read_chunk_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stream = IOStream(connection, io_loop=self.io_loop,</span><br><span class="line">                              max_buffer_size=self.max_buffer_size,</span><br><span class="line">                              read_chunk_size=self.read_chunk_size)</span><br><span class="line">        <span class="comment"># 处理stream</span></span><br><span class="line">        future = self.handle_stream(stream, address)</span><br><span class="line">        <span class="keyword">if</span> future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># 将future添加到IOLoop</span></span><br><span class="line">            self.io_loop.add_future(gen.convert_yielded(future),</span><br><span class="line">                                    <span class="keyword">lambda</span> f: f.result())</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        app_log.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></li></ul><p>以非ssl请求为例，tornado会实例化tornado.iostream.IOStream对象，用它去处理流，该对象主要封装了对请求数据读写的一些操作。之后会调用self.handle_stream(stream, address)，而该方法在tornado.HTTPServer中被实现。</p><ul><li><p>tornado.httpserver.HTTPServer.handle_stream()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_stream</span><span class="params">(self, stream, address)</span>:</span></span><br><span class="line">    <span class="comment"># 将相关参数保存上下文中，以便之后获取</span></span><br><span class="line">    context = _HTTPRequestContext(stream, address,</span><br><span class="line">                                  self.protocol,</span><br><span class="line">                                  self.trusted_downstream)</span><br><span class="line">    <span class="comment"># 初始化HTTP1ServerConnection实例</span></span><br><span class="line">    conn = HTTP1ServerConnection(</span><br><span class="line">        stream, self.conn_params, context)</span><br><span class="line">    <span class="comment"># 保存连接conn到self._connections</span></span><br><span class="line">    self._connections.add(conn)</span><br><span class="line">    <span class="comment"># 开始在该conn连接上处理请求</span></span><br><span class="line">    conn.start_serving(self)</span><br></pre></td></tr></table></figure></li></ul><p>该方法主要是完成了对HTTP1ServerConnection的初始化，以及通过调用start_serving开始处理请求。http1connection.HTTP1ServerConnection.start_serving()详解参考：<a href="../tornado_http1connection#start_serving">tornado http1connection解析</a></p><h2 id="相关方法解析"><a href="#相关方法解析" class="headerlink" title="相关方法解析"></a>相关方法解析</h2><ul><li><p><div id="start_request"></div>tornado.httpserver.HTTPServer.start_request()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_request</span><span class="params">(self, server_conn, request_conn)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(self.request_callback, httputil.HTTPServerConnectionDelegate):</span><br><span class="line">        delegate = self.request_callback.start_request(server_conn, request_conn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        delegate = _CallableAdapter(self.request_callback, request_conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.xheaders:</span><br><span class="line">        delegate = _ProxyAdapter(delegate, request_conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delegate</span><br></pre></td></tr></table></figure></li></ul><p>方法实现了父类tornado.httputil.HTTPServerConnectionDelegate中的start_request()方法，当新的请求开始时，这个方法会被服务器调用。通过上面tornado.httpserver.HTTPServer.initialize()详解可知，self.request_callback为tornado.web.Application实例，而tornado.web.Application刚好继承至httputil.HTTPServerConnectionDelegate，则会调用tornado.web.Application的start_request()方法。详解可参考：<a href="../tornado_application">tornado application解析</a>。最终返回的是继承至httputil.HTTPMessageDelegate的_RoutingDelegate对象，即delegate为httputil.HTTPMessageDelegate实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-httpserver&quot;&gt;&lt;a href=&quot;#tornado-httpserver&quot; class=&quot;headerlink&quot; title=&quot;tornado httpserver&quot;&gt;&lt;/a&gt;tornado httpserver&lt;/h2&gt;&lt;p&gt;tornado httpserver封装了对http请求的处理，是一个非阻塞、单线程的HTTP服务器。一个完整的web服务器示例如下，启动脚本后在浏览器访问&lt;a href=&quot;http://localhost:8888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost:8888&lt;/a&gt; ，页面会显示Hello，world：&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="httpserver" scheme="http://yoursite.com/tags/httpserver/"/>
    
  </entry>
  
  <entry>
    <title>tornado posix实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_platform_posix/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_platform_posix/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2018-04-03T03:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-posix"><a href="#tornado-posix" class="headerlink" title="tornado posix"></a>tornado posix</h2><p>tornado.platform.posix，Posix平台特定功能的实现。Posix平台指“可移植操作系统接口”（Portable Operation System Interface），最后的x代表类Unix系统。该文件主要是对Linux系统相关API的实现，Windows NT系列实现为tornado.platform.windows、tornado.platform.common。</p><a id="more"></a><ul><li>close-on-exec标志详解</li></ul><p>当我们fork子进程时，子进程以写时复制（COW，Copy-On-Write）方式获得父进程的数据空间、堆和栈副本，这其中也包括文件描述符。刚刚fork成功时，父子进程中相同的文件描述符指向系统文件表中的同一项（这也意味着他们共享同一文件偏移量）。</p><div align="center"><img src="/images/tornado-src-analysis/fork.gif" alignwidth="600" height="600" alt="tcp连接过程"></div><p>接着，在子进程中我们会exec另一个程序，此时会用全新的程序替换子进程的正文，数据，堆和栈等。此时保存文件描述符的变量当然也不存在了，我们就无法关闭无用的文件描述符了。所以通常我们会fork子进程后在子进程中直接执行close关掉无用的文件描述符，然后再执行exec。</p><p>但是在复杂系统中，有时我们fork子进程时已经不知道打开了多少个文件描述符（包括socket句柄等），这此时进行逐一清理确实有很大难度。我们期望的是能在fork子进程前打开某个文件句柄时就指定好：“这个句柄我在fork子进程后执行exec时就关闭”。其实是有这样的方法的：即所谓的 close-on-exec。设置close-on-exec为FD_CLOEXEC，即1（系统默认为0），这样，当fork子进程后，仍然可以使用fd。但执行exec后系统就会字段关闭子进程中的fd了，即不能再在该文件中读写数据了。</p><ul><li><p>tornado.platform.posix</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_close_exec</span><span class="params">(fd)</span>:</span></span><br><span class="line">    <span class="comment"># 取得与文件描述符fd联合的close-on-exec标志，类似FD_CLOEXEC。</span></span><br><span class="line">    <span class="comment"># 如果返回值和FD_CLOEXEC进行与运算结果是0的话，文件保持交叉式访问exec()，</span></span><br><span class="line">    <span class="comment"># 否则如果通过exec运行的话，文件将被关闭</span></span><br><span class="line">    flags = fcntl.fcntl(fd, fcntl.F_GETFD)</span><br><span class="line">    <span class="comment"># 设置close-on-exec标志，该标志以参数arg的FD_CLOEXEC位决定，</span></span><br><span class="line">    <span class="comment"># 很多现存的涉及文件描述符标志的程序并不使用常数 FD_CLOEXEC，</span></span><br><span class="line">    <span class="comment"># 而是将此标志设置为0(系统默认，在exec时不关闭)或1(在exec时关闭) </span></span><br><span class="line">    fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_nonblocking</span><span class="params">(fd)</span>:</span></span><br><span class="line">    <span class="comment"># 取得fd的文件状态标志</span></span><br><span class="line">    flags = fcntl.fcntl(fd, fcntl.F_GETFL)</span><br><span class="line">    <span class="comment"># 设置fd描述符状态标志为非阻塞，如果read(1024)调用没有可读取的数据，</span></span><br><span class="line">    <span class="comment"># 或者如果write(1024)操作时写缓存区已满，</span></span><br><span class="line">    <span class="comment"># 则read或write调用将返回-1和EAGAIN错误，而不会被阻塞</span></span><br><span class="line">    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 唤醒者（另一线程）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waker</span><span class="params">(interface.Waker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        r, w = os.pipe()</span><br><span class="line">        _set_nonblocking(r)</span><br><span class="line">        _set_nonblocking(w)</span><br><span class="line">        set_close_exec(r)</span><br><span class="line">        set_close_exec(w)</span><br><span class="line">        self.reader = os.fdopen(r, <span class="string">"rb"</span>, <span class="number">0</span>)</span><br><span class="line">        self.writer = os.fdopen(w, <span class="string">"wb"</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fileno</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.reader.fileno()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_fileno</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.writer.fileno()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wake</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.writer.write(<span class="string">b"x"</span>)</span><br><span class="line">        <span class="keyword">except</span> (IOError, ValueError):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                result = self.reader.read()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.reader.close()</span><br><span class="line">        common.try_close(self.writer)</span><br></pre></td></tr></table></figure></li></ul><p>通过上面对close-on-exec标志的详解，再解读tornado.platform.posix就容易理解了。set_close_exec(fd)就是为了设置close-on-exec标志位为1；_set_nonblocking(fd)为了设置IO读写为非阻塞模式。</p><p>类Waker可以解释为唤醒者。它继承至tornado.platform.interface.Waker，是一个类似socket（pipe管道）的对象，可以从”select.select()“或“epoll.poll()”等类似函数唤醒另一个线程。tornado.ioloop.IOLoop将会把Waker的读文件描述符添加到”select“（或”epoll“或”kqueue“）中。</p><p>由于epoll.poll()（select.select()）函数是阻塞的，即当没有读写事件发生时会休眠，而当另一个线程想要唤醒IOLoop时，它会调用Waker.wake()，向pipe中写入数据，此时，已经被注册到epoll中的读管道pipe会被触发，从而epoll.poll()函数返回，即所谓唤醒了IOLoop。</p><p>IOLoop一旦醒来，它将调用Waker.consume()回调函数，以进行必要的每次唤醒清理，即将为唤醒IOLoop而写入的数据读完。当“IOLoop”关闭时，它也关闭了它的waker。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-posix&quot;&gt;&lt;a href=&quot;#tornado-posix&quot; class=&quot;headerlink&quot; title=&quot;tornado posix&quot;&gt;&lt;/a&gt;tornado posix&lt;/h2&gt;&lt;p&gt;tornado.platform.posix，Posix平台特定功能的实现。Posix平台指“可移植操作系统接口”（Portable Operation System Interface），最后的x代表类Unix系统。该文件主要是对Linux系统相关API的实现，Windows NT系列实现为tornado.platform.windows、tornado.platform.common。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="posix" scheme="http://yoursite.com/tags/posix/"/>
    
  </entry>
  
  <entry>
    <title>tornado配置类configurable的实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_util_configurable/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_util_configurable/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2018-04-02T10:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-util-configurable"><a href="#tornado-util-configurable" class="headerlink" title="tornado util configurable"></a>tornado util configurable</h2><p>tornado.util.Configurable，一个配置类，是工厂模式的实现，通过使用构造函数（<strong>new</strong>()）作为工厂方法。其子类必须实现configurable_base()、configurable_default()、initialize()。通过调用configure()函数去配置当基类（不是指Configurable，而是继承至Configurable的类，如tornado.ioloop.IOLoop）被实例化时使用的实现类，以及配置其实现类初始化的关键字参数。</p><a id="more"></a><p>示例：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> httpclient</span><br><span class="line"></span><br><span class="line">httpclient.AsyncHTTPClient.configure\</span><br><span class="line">(<span class="string">"tornado.curl_httpclient.CurlAsyncHTTPClient"</span>, max_clients=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">http_client = httpclient.AsyncHTTPClient()</span><br></pre></td></tr></table></figure><p>以tornado.httpclient.AsyncHTTPClient为示例来开始tornado.util.Configurable的剖析。从tornado源码可知，AsyncHTTPClient继承至Configurable，同时tornado.curl_httpclient.CurlAsyncHTTPClient继承至AsyncHTTPClient。</p><ul><li><p>第二行AsyncHTTPClient调用configure去设置它的实现类及关键字参数max_clients=10000。其源码中直接调用了父类（Configurable）的configure()函数。</p><ul><li><p>tornado.httpclient.AsyncHTTPClient.configure()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(cls, impl, **kwargs)</span>:</span></span><br><span class="line">    super(AsyncHTTPClient, cls).configure(impl, **kwargs)</span><br></pre></td></tr></table></figure></li><li><p>tornado.util.Configurable.configure()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(cls, impl, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># cls为AsyncHTTPClient，获取可配置层次结构的基类base（AsyncHTTPClient）</span></span><br><span class="line">    base = cls.configurable_base()</span><br><span class="line">    <span class="comment"># 由上面的例子得：impl="tornado.curl_httpclient.CurlAsyncHTTPClient"</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(impl, (str, unicode_type)):</span><br><span class="line">        <span class="comment"># 引入tornado.curl_httpclient.CurlAsyncHTTPClient到当前上下文环境</span></span><br><span class="line">        impl = import_object(impl)</span><br><span class="line">    <span class="keyword">if</span> impl <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> issubclass(impl, cls):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Invalid subclass of %s"</span> % cls)</span><br><span class="line">    <span class="comment"># 通过全局变量保存数据，这两个变量是初始化实例</span></span><br><span class="line">    <span class="comment"># （tornado.util.Configurable.__new__()）时非常重要的数据</span></span><br><span class="line">    <span class="comment"># 值为：tornado.curl_httpclient.CurlAsyncHTTPClient</span></span><br><span class="line">    base.__impl_class = impl </span><br><span class="line">    <span class="comment"># 值为：&#123;"max_clients": 10000&#125;</span></span><br><span class="line">    base.__impl_kwargs = kwargs</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三行获取AsyncHTTPClient实例，将会调用tornado.util.Configurable.<strong>new</strong>()函数。</p><ul><li><p>tornado.util.Configurable.<strong>new</strong>()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># cls为AsyncHTTPClient，获取可配置层次结构的基类，</span></span><br><span class="line">    <span class="comment"># 通常是其自身（如tornado.httpclient.AsyncHTTPClient.configurable_base()）</span></span><br><span class="line">    base = cls.configurable_base()</span><br><span class="line">    init_kwargs = &#123;&#125;</span><br><span class="line">    <span class="comment"># 判断cls是否是基类base</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> base:</span><br><span class="line">        <span class="comment"># 获取当前配置的实现类，因为之前配置过实现类，即第二行，</span></span><br><span class="line">        <span class="comment"># 所以得到impl为tornado.curl_httpclient.CurlAsyncHTTPClient</span></span><br><span class="line">        impl = cls.configured_class()</span><br><span class="line">        <span class="comment"># 判断configure()函数配置的关键字参数是否为空</span></span><br><span class="line">        <span class="keyword">if</span> base.__impl_kwargs:</span><br><span class="line">            <span class="comment"># 更新初始化参数字典，因为之前配置过关键字参数，即第二行，</span></span><br><span class="line">            <span class="comment"># base.__impl_kwargs=&#123;"max_clients": 10000&#125;</span></span><br><span class="line">            init_kwargs.update(base.__impl_kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 实现类即为cls</span></span><br><span class="line">        impl = cls</span><br><span class="line">    <span class="comment"># 更新初始化参数字典</span></span><br><span class="line">    init_kwargs.update(kwargs)</span><br><span class="line">    <span class="comment"># 实例化cls，如示例，instance为tornado.curl_httpclient.CurlAsyncHTTPClient</span></span><br><span class="line">    instance = super(Configurable, cls).__new__(impl)</span><br><span class="line">    <span class="comment"># 初始化实例参数</span></span><br><span class="line">    instance.initialize(*args, **init_kwargs)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure></li><li><p>tornado.util.Configurable.configured_class()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configured_class</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># cls为AsyncHTTPClient</span></span><br><span class="line">    base = cls.configurable_base()</span><br><span class="line">    <span class="comment"># 判断有没有调用tornado.util.Configurable.configure()函数进行配置，</span></span><br><span class="line">    <span class="comment"># 如果没有配置过，就调用默认设置configurable_default()</span></span><br><span class="line">    <span class="keyword">if</span> cls.__impl_class <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        base.__impl_class = cls.configurable_default()</span><br><span class="line">    <span class="keyword">return</span> base.__impl_class</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>tornado.util.Configurable.configured_class()函数是选取实现类的关键，它会判断是否调用过tornado.util.Configurable.configure()函数去配置实现类了，然后以此选择相应的实现类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-util-configurable&quot;&gt;&lt;a href=&quot;#tornado-util-configurable&quot; class=&quot;headerlink&quot; title=&quot;tornado util configurable&quot;&gt;&lt;/a&gt;tornado util configurable&lt;/h2&gt;&lt;p&gt;tornado.util.Configurable，一个配置类，是工厂模式的实现，通过使用构造函数（&lt;strong&gt;new&lt;/strong&gt;()）作为工厂方法。其子类必须实现configurable_base()、configurable_default()、initialize()。通过调用configure()函数去配置当基类（不是指Configurable，而是继承至Configurable的类，如tornado.ioloop.IOLoop）被实例化时使用的实现类，以及配置其实现类初始化的关键字参数。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="configurable" scheme="http://yoursite.com/tags/configurable/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用（Reactor）详解</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/io_multiplexing/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/io_multiplexing/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2018-04-02T10:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO多路复用（Reactor）"><a href="#IO多路复用（Reactor）" class="headerlink" title="IO多路复用（Reactor）"></a>IO多路复用（Reactor）</h2><p>   IO多路复用技术是为实现单线程处理多请求连接，减少系统因频繁的创建线程或进程而产生的资源消耗，这里的复用特指同时使用单一线程。linux下的select、poll、epoll为IO多路复用的具体实现。当客户端与服务端的socket连接建立之后，程序将该socket文件描述符注册到epoll，然后返回，最终交由epoll去管理。epoll可以同时监听多个文件描述符，当某个或某些文件描述符就绪，则通知程序进行相应的读写操作，否则会一直阻塞知道有文件描述符就绪。我们使用epoll编程时，会设置socket非阻塞模式。所以，IO多路复用是同步非阻塞IO。</p><a id="more"></a><ul><li><p>select、poll、epoll比较</p><ul><li><p>select</p><p>  select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p><p>  select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>  缺点：</p><ul><li>每次调用select都需要把文件描述符（FD）从用户态拷贝到内核，开销比较大</li><li>每次都需要在内核遍历传入的文件描述符（FD）</li><li>select支持文件数量比较小，默认是1024。当然，也可以通过修改宏定义改掉，但这会造成效率的降低。</li></ul></li><li><p>poll</p><p>  poll及轮训，poll和select本质上是一样的，只是描述fd集合的方式不同。poll使用的是pollfd结构，select使用的是fd_set结构。</p></li><li><p>epoll</p><p>  epoll是对select和poll的改进，而且改正了select、poll的三个缺点和不足。</p><p>  相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>  优点：</p><ul><li>每次注册新事件到epoll句柄都会把所有的fd拷贝进来，而不是在epoll_wait中重复拷贝，这样确保fd只会被拷贝一次</li><li>epoll不是像select/poll那样每次都把fd加入等待队列，epoll把每个fd指定一个回调函数，当设备就绪时，唤醒等待队列的等待者就会调用其它的回调函数，这个回调函数会把就绪的fd放入一个就绪链表。epoll_wait就是在这个就绪链表中查看有没有就绪fd。</li><li><p>epoll没有fd数目限制</p><p>缺点：</p></li><li><p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p><p>模式：</p></li><li><p>水平触发（level-triggered）：满足状态时触发</p><p>  当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上次没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！</p></li><li><p>边缘触发（edge-triggered）：状态改变时触发</p><p>  当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你去读写余下的数据！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！</p><p>例如一个socket经过长时间等待后接收到一段100k的数据，两种触发方式都会向程序发出就绪通知。假设程序从这个socket中读取了50k数据，并再次调用监听函数，水平触发依然会发出就绪通知，而边缘触发会因为socket“有数据可读”这个状态没有发生变化而不发出通知且陷入长时间的等待。</p></li></ul></li><li><p>总结：</p><ul><li>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列）。这也能节省不少的开销。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO多路复用（Reactor）&quot;&gt;&lt;a href=&quot;#IO多路复用（Reactor）&quot; class=&quot;headerlink&quot; title=&quot;IO多路复用（Reactor）&quot;&gt;&lt;/a&gt;IO多路复用（Reactor）&lt;/h2&gt;&lt;p&gt;   IO多路复用技术是为实现单线程处理多请求连接，减少系统因频繁的创建线程或进程而产生的资源消耗，这里的复用特指同时使用单一线程。linux下的select、poll、epoll为IO多路复用的具体实现。当客户端与服务端的socket连接建立之后，程序将该socket文件描述符注册到epoll，然后返回，最终交由epoll去管理。epoll可以同时监听多个文件描述符，当某个或某些文件描述符就绪，则通知程序进行相应的读写操作，否则会一直阻塞知道有文件描述符就绪。我们使用epoll编程时，会设置socket非阻塞模式。所以，IO多路复用是同步非阻塞IO。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="IO多路复用" scheme="http://yoursite.com/tags/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
      <category term="select" scheme="http://yoursite.com/tags/select/"/>
    
      <category term="poll" scheme="http://yoursite.com/tags/poll/"/>
    
      <category term="epoll" scheme="http://yoursite.com/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>tornado ioloop实现解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/tornado_ioloop/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/tornado_ioloop/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2018-04-03T03:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tornado-ioloop"><a href="#tornado-ioloop" class="headerlink" title="tornado ioloop"></a>tornado ioloop</h2><p>tornado ioloop是一个基于水平触发的非阻塞socket的IO事件循环。在Linux系统上会使用epoll，Mac和BSD系统中使用kqueue，否则使用select。在分析源码之前需要搞清楚几个知识点：</p><ul><li><a href="../socket">socket（TCP三次握手、四次挥手）</a></li><li><a href="../io_multiplexing">IO多路复用（select、epoll、kqueue）</a></li></ul><a id="more"></a><p>ioloop.IOLoop，继承至tornado.util.Configurable（主要用于子类的创建）。IOLoop首先会获取一个全局锁，以保证全局只有一个IOLoop，即单例模式。IOLoop使用事例：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connection_ready</span><span class="params">(sock, fd, events)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            connection, address = sock.accept()</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        connection.setblocking(<span class="number">0</span>)</span><br><span class="line">        handle_connection(connection, address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.setblocking(<span class="number">0</span>)</span><br><span class="line">    sock.bind((<span class="string">""</span>, port))</span><br><span class="line">    sock.listen(<span class="number">128</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取IOLoop对象</span></span><br><span class="line">    io_loop = tornado.ioloop.IOLoop.current()</span><br><span class="line">    callback = functools.partial(connection_ready, sock)</span><br><span class="line">    io_loop.add_handler(sock.fileno(), callback, io_loop.READ)</span><br><span class="line">    <span class="comment"># 启动IOLoop</span></span><br><span class="line">    io_loop.start()</span><br></pre></td></tr></table></figure><p>从事例中知道，使用ioloop事件循环，首先需要获取IOLoop对象，即调用tornado.ioloop.IOLoop.current()：</p><ul><li><p>tornado.ioloop.IOLoop.current()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current</span><span class="params">(instance=True)</span>:</span></span><br><span class="line">    current = getattr(IOLoop._current, <span class="string">"instance"</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> current <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> instance:</span><br><span class="line">        <span class="keyword">return</span> IOLoop.instance()</span><br><span class="line">    <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure></li></ul><p>该函数只有四行，它先判断当前线程中是否有IOLoop实例正在运行或者被IOLoop.make_current()标记过，如果结果为真就直接返回当前IOLoop，否则调用IOLoop.instance()去创建IOLoop实例。</p><ul><li>tornado.ioloop.IOLoop.instance()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 第一层检查</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</span><br><span class="line">        <span class="keyword">with</span> IOLoop._instance_lock:</span><br><span class="line">            <span class="comment"># 第二层检查</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</span><br><span class="line">                <span class="comment"># New instance after double check</span></span><br><span class="line">                IOLoop._instance = IOLoop()</span><br><span class="line">    <span class="keyword">return</span> IOLoop._instance</span><br></pre></td></tr></table></figure><p>在该方法中使用了两次判断，用以实现单例。第一层判断只是为了提升性能，其实只需第二层判断就已经可以实现单例模式。但是如果没有第一层判断，我们只有实例化IOLoop的时候需要加锁，其他时候IOLoop实例已经存在了，不需要加锁了，但是这时其他需要IOLoop实例的线程还是必须等待锁，锁的存在明显降低了效率，有性能损耗。</p><p>两层检查都没通过时，会初始化IOLoop对象（调用IOLoop._instance = IOLoop()）。此时，调用IOLoop父类<a href="../tornado_util_configurable">tornado.util.Configurable</a>的<strong>new</strong>()方法实例化IOLoop对象。因为没有调用tornado.util.Configurable.configure()函数配置实现类，因此Configurable会调用tornado.ioloop.IOLoop.configurable_default()默认配置实现类（不同系统选择不同的IO多路复用机制，即epoll、kqueue、select）。</p><ul><li><p>tornado.ioloop.IOLoop.configurable_default()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configurable_default</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 判断系统是否实现epoll，如果有就使用EPollIOLoop作为实现类</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"epoll"</span>):</span><br><span class="line">        <span class="keyword">from</span> tornado.platform.epoll <span class="keyword">import</span> EPollIOLoop</span><br><span class="line">        <span class="keyword">return</span> EPollIOLoop</span><br><span class="line">    <span class="comment"># 判断系统是否实现kqueue， 如果有就使用KQueueIOLoop作为实现类</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"kqueue"</span>):</span><br><span class="line">        <span class="comment"># Python 2.6+ on BSD or Mac</span></span><br><span class="line">        <span class="keyword">from</span> tornado.platform.kqueue <span class="keyword">import</span> KQueueIOLoop</span><br><span class="line">        <span class="keyword">return</span> KQueueIOLoop</span><br><span class="line">    <span class="comment"># 否则使用SelectIOLoop作为实现类</span></span><br><span class="line">    <span class="keyword">from</span> tornado.platform.select <span class="keyword">import</span> SelectIOLoop</span><br><span class="line">    <span class="keyword">return</span> SelectIOLoop</span><br></pre></td></tr></table></figure></li></ul><p>此处我们默认选择EPollIOLoop作为实现类。通过Configurable会生成EPollIOLoop实例，并调用tornado.platform.epoll.EPollIOLoop.initialize()。</p><ul><li><p>tornado.platform.epoll.EPollIOLoop</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollIOLoop</span><span class="params">(PollIOLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用PollIOLoop.initialize()</span></span><br><span class="line">        super(EPollIOLoop, self).initialize(impl=select.epoll(), **kwargs)</span><br></pre></td></tr></table></figure></li><li><p>tornado.ioloop.PollIOLoop.initialize()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, impl, time_func=None, **kwargs)</span>:</span></span><br><span class="line">    super(PollIOLoop, self).initialize(**kwargs)</span><br><span class="line">    self._impl = impl</span><br><span class="line">    <span class="keyword">if</span> hasattr(self._impl, <span class="string">'fileno'</span>):</span><br><span class="line">        <span class="comment"># 设置select.epoll描述符在子进程执行exec()族函数时自动关掉</span></span><br><span class="line">        set_close_exec(self._impl.fileno())</span><br><span class="line">    self.time_func = time_func <span class="keyword">or</span> time.time</span><br><span class="line">    self._handlers = &#123;&#125;</span><br><span class="line">    self._events = &#123;&#125;</span><br><span class="line">    self._callbacks = collections.deque()</span><br><span class="line">    self._timeouts = []</span><br><span class="line">    self._cancellations = <span class="number">0</span></span><br><span class="line">    self._running = <span class="keyword">False</span></span><br><span class="line">    self._stopped = <span class="keyword">False</span></span><br><span class="line">    self._closing = <span class="keyword">False</span></span><br><span class="line">    self._thread_ident = <span class="keyword">None</span></span><br><span class="line">    self._blocking_signal_threshold = <span class="keyword">None</span></span><br><span class="line">    self._timeout_counter = itertools.count()</span><br><span class="line">    <span class="comment"># 创建一个pipe（管道），当IOLoop处于空闲，即无读写事件时，</span></span><br><span class="line">    <span class="comment"># 会向该pipe中发送虚假数据从而叫醒IOLoop</span></span><br><span class="line">    self._waker = Waker()</span><br><span class="line">    <span class="comment"># 将唤醒者（waker）读文件描述符注册到epoll，</span></span><br><span class="line">    <span class="comment"># 当另一线程调用tornado.ioloop.PollIOLoop.add_callback()时，</span></span><br><span class="line">    <span class="comment"># 会调用self._waker.wake()唤醒IOLoop，从而让注册的回调函数运行。</span></span><br><span class="line">    <span class="comment"># 由于唤醒正在轮训中的IOLoop比它自动唤醒（超时）消耗资源相对昂贵，</span></span><br><span class="line">    <span class="comment"># 所以在IOLoop同一线程中不会去主动唤醒它。</span></span><br><span class="line">    self.add_handler(self._waker.fileno(),</span><br><span class="line">                     <span class="keyword">lambda</span> fd, events: self._waker.consume(),</span><br><span class="line">                     self.READ)</span><br></pre></td></tr></table></figure></li></ul><p>方法中都是进行一些全局数据的初始化工作。其中对epoll文件描述符设置fork时自动关闭以及叫醒IOLoop机制可参考<a href="../tornado_platform_posix">tornado platform posix解析</a></p><p>IOLoop初始化完成之后就会调用IOLoop.start()方法去启动IOLoop，是IOLoop的核心。此方法在PollIOLoop中实现。</p><ul><li><p><div id="start"></div>tornado.ioloop.PollIOLoop.start()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">if</span> self._running:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"IOLoop is already running"</span>)</span><br><span class="line">self._setup_logging()</span><br><span class="line"><span class="keyword">if</span> self._stopped:</span><br><span class="line">    self._stopped = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">old_current = getattr(IOLoop._current, <span class="string">"instance"</span>, <span class="keyword">None</span>)</span><br><span class="line">IOLoop._current.instance = self</span><br><span class="line">self._thread_ident = thread.get_ident()</span><br><span class="line">self._running = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># signal.set_wakeup_fd解决了事件循环中的条件竞争：select/poll/etc在开始进入</span></span><br><span class="line"><span class="comment"># 中断休眠之前一个信号可能会到达，因此信号可能在没有唤醒select时被处理消耗掉。</span></span><br><span class="line"><span class="comment"># 解决方法与C语言中的同步机制一样，将信号处理程序写入管道，然后通过select获取。</span></span><br><span class="line">old_wakeup_fd = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> hasattr(signal, <span class="string">'set_wakeup_fd'</span>) <span class="keyword">and</span> os.name == <span class="string">'posix'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将唤醒者写管道文件描述符注册为wakeup_fd，当一个信号到来</span></span><br><span class="line">        <span class="comment"># 时（如SIGINT，即Ctrl+C），会向其中写入"\0"，从而唤醒select或poll。</span></span><br><span class="line">        <span class="comment"># 该函数返回上次设置的文件描述符，如果之前没设置过，则返回-1</span></span><br><span class="line">        old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())</span><br><span class="line">        <span class="comment"># 当返回值为-1则说明之前已经设置过wakeup_fd，然后重置</span></span><br><span class="line">        <span class="keyword">if</span> old_wakeup_fd != <span class="number">-1</span>:</span><br><span class="line">            signal.set_wakeup_fd(old_wakeup_fd)</span><br><span class="line">            old_wakeup_fd = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        old_wakeup_fd = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 为了避免IO事件饥饿，将新添加的回调延迟到事件循环的下一次迭代中。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># epoll水平触发模式下，当有大量文件描述符就绪需要处理时，</span></span><br><span class="line">        <span class="comment"># 可能会导致事件太多而没有执行到新添加的回调，这样就会造成IO事件饥饿。</span></span><br><span class="line">        ncallbacks = len(self._callbacks)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># timeouts是tornado封装好的超时处理器</span></span><br><span class="line">        due_timeouts = [] <span class="comment"># 保存本次迭代需要执行的超时任务</span></span><br><span class="line">        <span class="keyword">if</span> self._timeouts:</span><br><span class="line">            now = self.time()</span><br><span class="line">            <span class="keyword">while</span> self._timeouts:</span><br><span class="line">                <span class="comment"># 超时事件的回调函数已经被取消，即该超时事件已无效</span></span><br><span class="line">                <span class="keyword">if</span> self._timeouts[<span class="number">0</span>].callback <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    heapq.heappop(self._timeouts)</span><br><span class="line">                    self._cancellations -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 当前时间是否已超过超时事件的最后期限，如已超过，则将其取出并</span></span><br><span class="line">                <span class="comment"># 保存到due_timeouts，然后执行</span></span><br><span class="line">                <span class="keyword">elif</span> self._timeouts[<span class="number">0</span>].deadline &lt;= now:</span><br><span class="line">                    due_timeouts.append(heapq.heappop(self._timeouts))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 优化，当超时事件被取消的次数大于512次并且大于超时事件数量的一</span></span><br><span class="line">            <span class="comment"># 半时，清理所有被取消的超时事件</span></span><br><span class="line">            <span class="keyword">if</span> (self._cancellations &gt; <span class="number">512</span> <span class="keyword">and</span></span><br><span class="line">                    self._cancellations &gt; (len(self._timeouts) &gt;&gt; <span class="number">1</span>)):</span><br><span class="line">                self._cancellations = <span class="number">0</span></span><br><span class="line">                self._timeouts = [x <span class="keyword">for</span> x <span class="keyword">in</span> self._timeouts</span><br><span class="line">                                  <span class="keyword">if</span> x.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]</span><br><span class="line">                heapq.heapify(self._timeouts)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行所有callback函数，及已经超时的超时事件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ncallbacks):</span><br><span class="line">            self._run_callback(self._callbacks.popleft())</span><br><span class="line">        <span class="keyword">for</span> timeout <span class="keyword">in</span> due_timeouts:</span><br><span class="line">            <span class="keyword">if</span> timeout.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self._run_callback(timeout.callback)</span><br><span class="line">        <span class="comment"># 释放资源</span></span><br><span class="line">        due_timeouts = timeout = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果有回调函数，则epoll.poll(timeout)函数的timeout为0</span></span><br><span class="line">        <span class="keyword">if</span> self._callbacks:</span><br><span class="line">            poll_timeout = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 如果没有回调函数且有超时事件，则poll的timeout为：</span></span><br><span class="line">        <span class="comment"># 首先获取最近的超时事件的最后期限与当前事件的差值，然后该值与poll的</span></span><br><span class="line">        <span class="comment"># timeout的默认值两者取较小值，再与0比较取较大值</span></span><br><span class="line">        <span class="keyword">elif</span> self._timeouts:</span><br><span class="line">            poll_timeout = self._timeouts[<span class="number">0</span>].deadline - self.time()</span><br><span class="line">            poll_timeout = max(<span class="number">0</span>, min(poll_timeout, _POLL_TIMEOUT))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            poll_timeout = _POLL_TIMEOUT</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._running:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取消信号定时器</span></span><br><span class="line">        <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 整个方法的核心，即epoll.poll(timeout)</span></span><br><span class="line">            event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            signal.setitimer(signal.ITIMER_REAL,</span><br><span class="line">                             self._blocking_signal_threshold, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理IO事件</span></span><br><span class="line">        self._events.update(event_pairs)</span><br><span class="line">        <span class="keyword">while</span> self._events:</span><br><span class="line">            fd, events = self._events.popitem()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 通过文件描述符获取在PollIOLoop.add_handler()</span></span><br><span class="line">                <span class="comment"># 方法中绑定到self._handlers中的socket对象及处理函数</span></span><br><span class="line">                fd_obj, handler_func = self._handlers[fd]</span><br><span class="line">                <span class="comment"># 调用处理器函数</span></span><br><span class="line">                handler_func(fd_obj, events)</span><br><span class="line">            <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果有异常则调用异常处理函数</span></span><br><span class="line">                    self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">        <span class="comment"># 释放资源</span></span><br><span class="line">        fd_obj = handler_func = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    self._stopped = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    IOLoop._current.instance = old_current</span><br><span class="line">    <span class="keyword">if</span> old_wakeup_fd <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        signal.set_wakeup_fd(old_wakeup_fd)</span><br></pre></td></tr></table></figure></li></ul><p>对start()方法中的timeouts的详解可以参考<a href="../tornado_ioloop_PeriodicCallback">tornado定时器PeriodicCallback解析</a>，其中针对特定实例做了相关分析，能加深理解。callbacks与timeouts的处理是相似的。</p><p>tornado IOLoop中对epoll.register()、epoll.modify()、epoll.unregister()分别做了封装，对应PollIOLoop.add_handler()、PollIOLoop.update_handler()、PollIOLoop.remove_handler()，分别表示注册文件描述符到epoll中、更新epoll中监听文件描述符的事件类型、删除epoll中监听的文件描述符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tornado-ioloop&quot;&gt;&lt;a href=&quot;#tornado-ioloop&quot; class=&quot;headerlink&quot; title=&quot;tornado ioloop&quot;&gt;&lt;/a&gt;tornado ioloop&lt;/h2&gt;&lt;p&gt;tornado ioloop是一个基于水平触发的非阻塞socket的IO事件循环。在Linux系统上会使用epoll，Mac和BSD系统中使用kqueue，否则使用select。在分析源码之前需要搞清楚几个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;../socket&quot;&gt;socket（TCP三次握手、四次挥手）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;../io_multiplexing&quot;&gt;IO多路复用（select、epoll、kqueue）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="ioloop" scheme="http://yoursite.com/tags/ioloop/"/>
    
  </entry>
  
  <entry>
    <title>tornado源码解析</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/README/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/README/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2018-04-03T03:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>   此项目主要是针对python web框架——tornado源码相关模块进行解析，加深对web开发的理解。在详解某一模块时会引入相关基础知识概念。包括以下几个知识点：</p><ul><li><a href="../tornado_ioloop">tornado.ioloop</a><ul><li><a href="../socket">socket（TCP三次握手、四次挥手）</a></li><li><a href="../io_multiplexing">IO多路复用（select、epoll、kqueue）</a></li><li><a href="../tornado_platform_posix">tornado中对posix接口的实现</a></li><li><a href="../tornado_ioloop_PeriodicCallback">tornado定时器</a></li><li><a href="../tornado_util_configurable">tornado配置类Configurable</a></li></ul></li><li><a href="../tornado_httpserver">tornado.httpserver</a></li><li><a href="../tornado_iostream">tornado.iostream</a></li><li><a href="../tornado_http1connection">tornado.http1connection</a></li><li><a href="../tornado_concurrent">tornado.concurrent</a></li><li><a href="../tornado_gen">tornado.gen</a></li><li><a href="../tornado_application">tornado.application</a></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>python 2.7</li><li>tornado 4.5.1</li><li>Ubuntu 16.04</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;   此项目主要是针对python web框架——tornado源码相关模块进行解析，加深对web开发的理解。在详解某一模块时会引入相关基础
      
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>Socket详解</title>
    <link href="http://yoursite.com/post/tornado-src-analysis/socket/"/>
    <id>http://yoursite.com/post/tornado-src-analysis/socket/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2018-04-03T02:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><ol><li>socket是网络进程之间的通讯方式，是对TCP/IP协议的封装。socket并不是像HTTP、TCP、IP一样的协议，而是一组调用接口（API）。通过socket，可以使用TCP/IP协议，即可以在网络上传输数据。</li></ol><a id="more"></a><ol start="2"><li>http是应用层协议，web开发中最常见的协议。当我们在浏览器输入一个网址，比如<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>时:<ul><li>浏览器首先会去查看本地hosts文件，通过域名（google.com）获取其对应的IP地址，如果本地没有找到，则继续向上层请求DNS服务器，DNS服务器就像一个树结构，一层一层的向上递进查找。</li><li>获取IP地址之后，浏览器会根据IP与默认端口80，通过TCP协议三次握手与服务器建立socket连接。</li><li>在linux下，一切皆文件。系统将每一个socket连接也抽象成一个文件，客户端与服务器建立连接之后，各自在本地进程中维护一个文件，然后可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li></ul></li></ol><h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><ul><li><p><strong>TCP连接到断开过程：</strong></p>  <div align="center"><img src="/images/tornado-src-analysis/tcp.jpg" alignwidth="700" height="700" alt="tcp连接过程"></div><ul><li><p>三次握手：</p><p>  第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认；</p><p>  第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；此时，内核将连接（socket）放入SYN QUEUE，即 <strong><em>未完成队列</em></strong> ，该队列大小由/proc/sys/net/ipv4/tcp_max_syn_backlog设定；</p><p>  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。此时，内核将连接（socket）移到ACCEPT QUEUE，即 <strong><em>已完成队列</em></strong> ，队列大小为socket listen(backlog)函数传入的backlog参数与/proc/sys/net/core/somaxconn决定，取二者最小值。服务器程序调用accept函数后，该连接（socket）被内核从已完成队列移除，并交由服务器程序控制。</p><p>  <strong><em>注意</em></strong> : TCP三次握手在应用程序调用accept函数之前由内核完成。调用accept只是获取已经完成的连接。</p></li><li><p>四次挥手</p><p>  第一次挥手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>  第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>  第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p>  第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那么，主机1也可以关闭连接了</p></li></ul></li><li><p><strong>client状态过程：</strong></p> <div align="center"><img src="/images/tornado-src-analysis/client-status.png" alignwidth="600" height="600" alt="tcp连接过程"></div></li><li><p><strong>server状态过程：</strong></p> <div align="center"><img src="/images/tornado-src-analysis/server-status.png" alignwidth="600" height="600" alt="tcp连接过程"></div></li></ul><h2 id="socket实例"><a href="#socket实例" class="headerlink" title="socket实例"></a>socket实例</h2><ul><li><p>server.py</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = <span class="number">3267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个IPV4且基于TCP协议的socket对象</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定监听端口</span></span><br><span class="line">server.bind((HOST, PORT))</span><br><span class="line"><span class="comment"># 开始监听端口，并且等待连接的最大数量为5</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"waiting for connection..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 接受连接（此方法阻塞）</span></span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Connected by "</span>, addr</span><br><span class="line">    </span><br><span class="line">    buffer = StringIO.StringIO()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 每次最多读取1k数据</span></span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"receive client data: "</span>, data</span><br><span class="line">            buffer.write(data)</span><br><span class="line">            conn.sendall(<span class="string">"Hello, &#123;&#125;"</span>.format(data))</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"receive client ALL datas: "</span>, buffer.getvalue()</span><br><span class="line">    buffer.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Connection from %s:%s closed.'</span> % addr</span><br></pre></td></tr></table></figure></li><li><p>client.py</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = <span class="number">3267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个IPV4且基于TCP协议的socket对象</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">client.connect((HOST, PORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获取用户控制台输入</span></span><br><span class="line">        data = raw_input(<span class="string">"please input something: "</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 关闭客户端连接</span></span><br><span class="line">        client.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    client.send(data)</span><br><span class="line">    result = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"client result: "</span>, result</span><br></pre></td></tr></table></figure></li><li><p>运行过程：</p><ol><li>运行server.py文件，系统进程会启动一个本地socket，该socket会一直循环等待客户端socket的连接。</li><li>当我们运行client.py文件后，客户端会与服务端建立连接。此时，客户端文件会读取用户在控制台的输入数据，然后发送给服务器。</li></ol></li><li><p>问题：<br>  当多开一个控制台再次运行client.py时,此时是无法与服务器建立连接的。因为该程序是单线程的，也就是同一时间服务器只能被一个客户端连接。</p></li><li><p>传统解决方法：<br>  传统解决方式就是多线程，一个客户端连接开启一个线程去处理。修改后的server.py如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = <span class="number">3267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个IPV4且基于TCP协议的socket对象</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定监听端口</span></span><br><span class="line">server.bind((HOST, PORT))</span><br><span class="line"><span class="comment"># 开始监听端口，并且等待连接的最大数量为5</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"waiting for connection..."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_conn</span><span class="params">(conn, addr)</span>:</span></span><br><span class="line">    buffer = StringIO.StringIO()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 每次最多读取1k数据</span></span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"receive client data: "</span>, data</span><br><span class="line">            buffer.write(data)</span><br><span class="line">            conn.sendall(<span class="string">"Hello, &#123;&#125;"</span>.format(data))</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"receive client ALL datas: "</span>, buffer.getvalue()</span><br><span class="line">    buffer.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Connection from %s:%s closed.'</span> % addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 接受连接（此方法阻塞）</span></span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Connected by "</span>, addr</span><br><span class="line">    </span><br><span class="line">    threading.Thread(target=handle_conn, args=(conn, addr)).start()</span><br></pre></td></tr></table></figure></li><li><p>优化解决方法：<br>  传统解决方法显然不现实，无法承受高并发、高访问量，线程对资源的消耗太大。为解决此问题，引入新概念：<a href="../io_multiplexing">IO多路复用</a>（Linux下select/poll/epoll），即事件驱动，所谓的Reactor模式。它实现了单线程连接多客户端。使用epoll实现server.py：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = <span class="number">3267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个IPV4且基于TCP协议的socket对象</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定监听端口</span></span><br><span class="line">server.bind((HOST, PORT))</span><br><span class="line"><span class="comment"># 开始监听端口，并且等待连接的最大数量为5</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 设置非阻塞</span></span><br><span class="line">server.setblocking(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取epoll对象</span></span><br><span class="line">epoll = select.epoll()</span><br><span class="line"><span class="comment"># 向epoll中注册服务器socket描述符，监听读事件</span></span><br><span class="line">epoll.register(server.fileno(), select.EPOLLIN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"waiting for connection..."</span></span><br><span class="line"></span><br><span class="line">connections = &#123;&#125;</span><br><span class="line">requests = &#123;&#125;</span><br><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 当监听的socket文件描述符发生改变则会以列表的形式主动报告给用户进程（阻塞）</span></span><br><span class="line">    <span class="comment"># timeout为获取结果的时间（秒） 当timeout等于-1的时永远等待(默认就是-1)直</span></span><br><span class="line">    <span class="comment"># 到文件描述符发生改变，如果指定为1那么epoll每1秒进行汇报一次当前文件描述符</span></span><br><span class="line">    <span class="comment"># 的状态哪怕是没有文件描述符发生改变也会返回一个空值</span></span><br><span class="line">    events = epoll.poll(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 循环发生改变的socket，返回的每个对象都是一个元组：(socket描述符, 监听的事件)</span></span><br><span class="line">    <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</span><br><span class="line">        <span class="comment"># 判断是否为服务器socket描述符，如果是则为第一个连接</span></span><br><span class="line">        <span class="keyword">if</span> fileno == server.fileno():</span><br><span class="line">            <span class="comment"># 接受连接（此方法阻塞），每一次与客户端建立连接都会创建一个socket，即下面的conn</span></span><br><span class="line">            conn, addr = server.accept()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Connected by "</span>, addr</span><br><span class="line">            </span><br><span class="line">            conn_fd = conn.fileno()</span><br><span class="line">            <span class="comment"># 设置socket连接为非阻塞</span></span><br><span class="line">            conn.setblocking(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 将socket连接注册到epoll，监听读事件</span></span><br><span class="line">            epoll.register(conn_fd, select.EPOLLIN)</span><br><span class="line">            <span class="comment"># 保存所有连接</span></span><br><span class="line">            connections[conn_fd] = (conn, addr)</span><br><span class="line">        <span class="comment"># 判断是否为断开事件</span></span><br><span class="line">        <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">            <span class="comment"># 解除epoll对socket的监听</span></span><br><span class="line">            epoll.unregister(fileno)</span><br><span class="line">            <span class="comment"># 关闭socket连接</span></span><br><span class="line">            connections[fileno][<span class="number">0</span>].close()</span><br><span class="line">            <span class="keyword">del</span> connections[fileno]</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Connection from %s:%s closed.'</span> % connections[fileno][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 判断是否为读事件</span></span><br><span class="line">        <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">            conn = connections[fileno][<span class="number">0</span>]</span><br><span class="line">            buffer = StringIO.StringIO()</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 每次最多读取1k数据</span></span><br><span class="line">                    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">except</span> socket.error, e:</span><br><span class="line">                    <span class="comment"># import traceback</span></span><br><span class="line">                    <span class="comment"># print traceback.format_exc()</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"receive client data: "</span>, data</span><br><span class="line">                    buffer.write(data)</span><br><span class="line">                    conn.sendall(<span class="string">"Hello, &#123;&#125;"</span>.format(data))</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"receive client ALL datas: "</span>, buffer.getvalue()</span><br><span class="line">            </span><br><span class="line">            requests[fileno] = buffer.getvalue().strip()</span><br><span class="line">            epoll.modify(fileno, select.EPOLLOUT)</span><br><span class="line">            buffer.close()</span><br><span class="line">        <span class="comment"># 判断是否为写事件</span></span><br><span class="line">        <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">            connections[fileno].send(requests[fileno])</span><br><span class="line">            <span class="comment"># 写事件完成之后将该socket从监听写事件改为监听读事件</span></span><br><span class="line">            epoll.modify(fileno, select.EPOLLIN)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;socket&quot;&gt;&lt;a href=&quot;#socket&quot; class=&quot;headerlink&quot; title=&quot;socket&quot;&gt;&lt;/a&gt;socket&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;socket是网络进程之间的通讯方式，是对TCP/IP协议的封装。socket并不是像HTTP、TCP、IP一样的协议，而是一组调用接口（API）。通过socket，可以使用TCP/IP协议，即可以在网络上传输数据。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="tornado源码解析" scheme="http://yoursite.com/categories/tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="tcp/ip" scheme="http://yoursite.com/tags/tcp-ip/"/>
    
  </entry>
  
</feed>
